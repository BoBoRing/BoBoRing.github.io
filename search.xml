<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全国计算机三级数据库学习</title>
      <link href="/2022/03/26/My-Post15/"/>
      <url>/2022/03/26/My-Post15/</url>
      
        <content type="html"><![CDATA[<p>核心知识点思维导图如下：</p><p><img src="/2022/03/26/My-Post15/数据库技术知识总结.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语言 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言基础学习</title>
      <link href="/2021/11/26/My-Post14/"/>
      <url>/2021/11/26/My-Post14/</url>
      
        <content type="html"><![CDATA[<p>学习路线的思维导图如下：<br><img src="/2021/11/26/My-Post14/JAVAluxian.png" alt></p><h1 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1 基础语法"></a>1 基础语法</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><p>Java代码中的注释分为三种形式，分别是单行注释、多行注释和文档注释。<br><img src="/2021/11/26/My-Post14/zhushi.png" alt></p><p>注意：</p><p>1.多行注释不能嵌套多行注释；</p><p>2.文档注释用来解释这段代码的作用，敲/**然后回车会自动生成。</p><h2 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h2><p>Java的数据类型主要分为两大类，基本类型和引用类型。<br><img src="/2021/11/26/My-Post14/jibenleix.png" alt></p><p><img src="/2021/11/26/My-Post14/yinyongleix.png" alt></p><p><strong>字面量</strong></p><p>代码中直接写出来的数据类型值就叫字面量，代码中具体使用如下。<br><img src="/2021/11/26/My-Post14/zhengshu.png" alt></p><p><img src="/2021/11/26/My-Post14/fudian.png" alt></p><p><img src="/2021/11/26/My-Post14/zifu.png" alt></p><p><img src="/2021/11/26/My-Post14/buer.png" alt></p><p><img src="/2021/11/26/My-Post14/null.png" alt></p><p>注意：Java中if语句的条件必须是布尔类型，不像其它语言变量非0即表示真。</p><p>字面量中的<strong>转义序列</strong>的写法如下（右边为其对应的Unicode编码）：<br><img src="/2021/11/26/My-Post14/zhuanyi.png" alt></p><p>注意：</p><p>1.引用类型类似于C语言里面的指针类型；</p><p>2.字符串类型属于引用类型，字符串内容为空代表指向的位置不放任何字符串，而空值null表示没有任何指向；</p><p>3.为了增加代码的可读性，Java中可以在数字中使用下划线区分数字位数或者字节分组，具体使用示例如下图。<br><img src="/2021/11/26/My-Post14/xiahuaxian.png" alt></p><p><strong>变量初始化</strong></p><p>1.Java中任何变量在使用之前都必须要进行初始化（赋值）；</p><p>2.局部变量：需要程序员手动初始化；</p><p>3.非局部变量（实例变量、类变量）：编译器会自动给未初始化的变量设置一个初始值。<br><img src="/2021/11/26/My-Post14/chushihua.png" alt></p><h2 id="1-3-运算符"><a href="#1-3-运算符" class="headerlink" title="1.3 运算符"></a>1.3 运算符</h2><p><img src="/2021/11/26/My-Post14/yunsuanfu.png" alt></p><p>注意：</p><p>1.运算符的优先级上面一行比下面一行高；</p><p>2.同一行的优先级一样；</p><p>3.当多个优先级一样的运算符一起使用时，按照结合性进行运算（只有赋值运算符的结合性是从右到左，其他运算符的结合性都是从左到右）；</p><p>4.为了保证运算符按照预期执行，尽量多使用小括号；</p><p>5.算术表示式的运算结果必须被使用。</p><p><strong>字符串的拼接</strong><br><img src="/2021/11/26/My-Post14/pinjie.png" alt></p><p><strong>位运算</strong></p><p>运算符中的按位与<code>&amp;</code>、或<code>|</code>、异或<code>^</code>不仅可以应用到整数类型，还可以应用到布尔类型。<br><img src="/2021/11/26/My-Post14/weiyunsuan.png" alt></p><p>按位与<code>&amp;</code>、或<code>|</code>、异或<code>^</code>不具备短路功能，而逻辑与<code>&amp;&amp;</code>、或<code>||</code>具有短路功能，即只要第一个条件成立就不会执行后面的条件。</p><p>其它位运算符：<br><img src="/2021/11/26/My-Post14/youyi.png" alt></p><h2 id="1-4-类型转换"><a href="#1-4-类型转换" class="headerlink" title="1.4 类型转换"></a>1.4 类型转换</h2><p>类型转换分两种，拓宽和窄化。<br><img src="/2021/11/26/My-Post14/leixingzhuanh.png" alt></p><p><img src="/2021/11/26/My-Post14/leixingzhuanh2.png" alt></p><p>注意：布尔类型和其它类型之间不能相互转换。</p><p><strong>一元数字提升</strong>：表示将byte、short、char类型的一元数字自动提升为int类型（属于拓宽基本类型转换）。</p><p>在什么情况会自动提升：<br><img src="/2021/11/26/My-Post14/yiyuantisheng.png" alt></p><p>注意：图中程序倒数第一句是字面量赋值给char类型，可以执行；而倒数第二句是int类型赋值给char类型，需要加一个强制转换。</p><p><strong>二元数字提升</strong>：即如果二元运算的两个变量类型不一样的时候，需要转换成数据范围大的那个变量的类型，如果既不是double又不是float也不是long，那么大家都转换为int。<br><img src="/2021/11/26/My-Post14/eryuantisheng.png" alt></p><p>图中代码第三行两个byte相加都会转换成int，int到byte需要强制转换，第四五行有byte就会转换成int。</p><h2 id="1-5-关键字和标识符"><a href="#1-5-关键字和标识符" class="headerlink" title="1.5 关键字和标识符"></a>1.5 关键字和标识符</h2><p><strong>关键字</strong><br><img src="/2021/11/26/My-Post14/guanjianzi.png" alt></p><p><strong>标识符</strong><br><img src="/2021/11/26/My-Post14/biaoshifu.png" alt></p><p><strong>命名建议：</strong><br><img src="/2021/11/26/My-Post14/mingming.png" alt></p><h2 id="1-6-数组"><a href="#1-6-数组" class="headerlink" title="1.6 数组"></a>1.6 数组</h2><p><strong>数组的创建：</strong><br><img src="/2021/11/26/My-Post14/shuzuchuangjian.png" alt></p><p><strong>数组的内存：</strong><br><img src="/2021/11/26/My-Post14/shuzuneicun.png" alt></p><p><strong>数组的遍历：</strong><br><img src="/2021/11/26/My-Post14/shuzubianli.png" alt></p><p>注意：可以直接输出数组元素，如果输出数组会打印数组类型和十六进制的哈希值。</p><h2 id="1-7-方法"><a href="#1-7-方法" class="headerlink" title="1.7 方法"></a>1.7 方法</h2><p>Java中的方法其实就是其他编程语言中的函数。<br><img src="/2021/11/26/My-Post14/ff.png" alt></p><p><strong>可变参数</strong>：用三个点表示，可以传递任意数量任意类型的参数。<br><img src="/2021/11/26/My-Post14/kebiancanshu.png" alt></p><h1 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2 面向对象"></a>2 面向对象</h1><h1 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3 常用API"></a>3 常用API</h1><h1 id="4-数据结构（集合）"><a href="#4-数据结构（集合）" class="headerlink" title="4 数据结构（集合）"></a>4 数据结构（集合）</h1><p><img src="/2021/11/26/My-Post14/JAVASHUJUJIEGOUY.png" alt></p><p><img src="/2021/11/26/My-Post14/JAVASHUJUJIEGOU2.png" alt></p><h1 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5 多线程"></a>5 多线程</h1><h1 id="6-IO"><a href="#6-IO" class="headerlink" title="6 IO"></a>6 IO</h1><h1 id="7-异常"><a href="#7-异常" class="headerlink" title="7 异常"></a>7 异常</h1><h1 id="8-正则表达式"><a href="#8-正则表达式" class="headerlink" title="8 正则表达式"></a>8 正则表达式</h1>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的学习</title>
      <link href="/2021/11/20/My-Post12/"/>
      <url>/2021/11/20/My-Post12/</url>
      
        <content type="html"><![CDATA[<p><strong>SQL</strong>：结构化查询语言(Structured Query Language)，是对数据库进行操作的一种语言。</p><p>通过SQL语句我们可以方便的操作数据库中的数据库、表、数据。</p><p>​SQL是数据库管理系统都需要遵循的规范。不同的数据库生产厂商都支持SQL语句，但都有特有内容。</p><p>SQL语句分类：</p><p><strong>（1）DDL数据定义语言</strong>，用来定义数据库对象，如数据库，表，列等。关键字为create，drop，alter等。</p><p><strong>（2）DML数据操作语言</strong>，用来对数据库中表的数据进行增删改。关键字为insert，delete，update等。</p><p><strong>（3）DQL数据查询语言</strong>，用来查询数据库中表的记录(数据)。关键字为select，where等。</p><p><strong>（4）DCL数据控制语言</strong>(了解)，用来定义数据库的访问权限和安全级别，及创建用户。关键字为GRANT，REVOKE等。</p><h1 id="1-DDL语句"><a href="#1-DDL语句" class="headerlink" title="1 DDL语句"></a>1 DDL语句</h1><h2 id="1-1-创建数据库"><a href="#1-1-创建数据库" class="headerlink" title="1.1 创建数据库"></a>1.1 创建数据库</h2><p>直接创建数据库：</p><pre><code>CREATE DATABASE 数据库名;</code></pre><p>判断是否存在并创建数据库：</p><pre><code>CREATE DATABASE IF NOT EXISTS 数据库名;</code></pre><p>创建数据库并指定字符集(编码表)：</p><pre><code>CREATE DATABASE 数据库名 CHARACTER SET 字符集;</code></pre><p>MySQL8.0默认使用的字符集为utf8mb4(能使用任何类型数据)。</p><h2 id="1-2-查看数据库"><a href="#1-2-查看数据库" class="headerlink" title="1.2 查看数据库"></a>1.2 查看数据库</h2><p>查看所有的数据库：</p><pre><code>SHOW DATABASES;</code></pre><p>查看某个已创建数据库的信息：</p><pre><code>SHOW CREATE DATABASE 数据库名;</code></pre><h2 id="1-3-修改数据库"><a href="#1-3-修改数据库" class="headerlink" title="1.3 修改数据库"></a>1.3 修改数据库</h2><p>修改数据库字符集格式：</p><pre><code>ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;</code></pre><h2 id="1-4-删除数据库"><a href="#1-4-删除数据库" class="headerlink" title="1.4 删除数据库"></a>1.4 删除数据库</h2><pre><code>DROP DATABASE 数据库名;</code></pre><h2 id="1-5-使用数据库"><a href="#1-5-使用数据库" class="headerlink" title="1.5 使用数据库"></a>1.5 使用数据库</h2><p>查看正在使用的数据库：</p><pre><code>SELECT DATABASE();</code></pre><p>在对表进行操作前需要先使用/切换对应的数据库：</p><pre><code>USE 数据库名;</code></pre><h2 id="1-6-创建表"><a href="#1-6-创建表" class="headerlink" title="1.6 创建表"></a>1.6 创建表</h2><p>前提：先使用某个数据库。</p><p>语法：</p><pre><code>CREATE TABLE 表名 (字段名1 字段类型1, 字段名2 字段类型2);</code></pre><p>示例：创建student表包含id,name,birthday字段</p><pre><code>CREATE TABLE student (  id INT,  name VARCHAR(20),  birthday DATE);</code></pre><p>快速创建一个表结构相同的表：</p><pre><code>CREATE TABLE 新表名 LIKE 旧表名;</code></pre><h2 id="1-7-查看表"><a href="#1-7-查看表" class="headerlink" title="1.7 查看表"></a>1.7 查看表</h2><p>查看某个数据库中的所有表：</p><pre><code>SHOW TABLES;</code></pre><p>查看表结构：</p><pre><code>DESC 表名;</code></pre><p>查看创建表的SQL语句：</p><pre><code>SHOW CREATE TABLE 表名;</code></pre><h2 id="1-8-删除表"><a href="#1-8-删除表" class="headerlink" title="1.8 删除表"></a>1.8 删除表</h2><p>直接删除表：</p><pre><code>DROP TABLE 表名;</code></pre><p>判断表是否存在并删除表：</p><pre><code>DROP TABLE IF EXISTS 表名;</code></pre><h2 id="1-9-修改表结构"><a href="#1-9-修改表结构" class="headerlink" title="1.9 修改表结构"></a>1.9 修改表结构</h2><p>前提：在做开发之前库当中的所有表字段已经建立成功了，一般不需要修改只需要插入数据，但是难免因为团队讨论误差忘了加一些字段，这时候就需要这部分对表字段进行修改。</p><p>添加表列(表列即为表中的字段)：</p><pre><code>ALTER TABLE 表名 ADD 列名 类型;</code></pre><p>修改列类型：</p><pre><code>ALTER TABLE 表名 MODIFY列名 新的类型;</code></pre><p>修改列名：</p><pre><code>ALTER TABLE 表名 CHANGE 旧列名 新列名 类型;</code></pre><p>删除列：</p><pre><code>ALTER TABLE 表名 DROP 列名;</code></pre><p>修改表名：</p><pre><code>RENAME TABLE 表名 TO 新表名;</code></pre><p>修改表对应的字符集：</p><pre><code>ALTER TABLE 表名 character set 字符集;</code></pre><h1 id="2-DML语句"><a href="#2-DML语句" class="headerlink" title="2 DML语句"></a>2 DML语句</h1><h2 id="2-1-插入数据的语法"><a href="#2-1-插入数据的语法" class="headerlink" title="2.1 插入数据的语法"></a>2.1 插入数据的语法</h2><p>关键字说明：</p><pre><code>INSERT INTO 表名         –- 表示往哪张表中添加数据(字段名1, 字段名2, …)     -- 要给哪些字段设置值VALUES (值1, 值2, …);    -- 设置具体的值</code></pre><p>注意：</p><ul><li>值与字段必须对应，个数相同，类型相同；</li><li>值的数据大小必须在字段的长度范围内；</li><li>除了数值类型外，其它的字段类型的值必须使用引号引起（建议单引号）；</li><li>如果要插入空值，可以不写字段，或者插入null。</li></ul><h2 id="2-2-插入全部数据"><a href="#2-2-插入全部数据" class="headerlink" title="2.2 插入全部数据"></a>2.2 插入全部数据</h2><p>所有的字段名都写出来：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, 字段名3…) VALUES (值1, 值2, 值3);</code></pre><p>不写字段名（会按照表已有的字段顺序赋值）：</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, 值3…);</code></pre><h2 id="2-3-插入部分数据"><a href="#2-3-插入部分数据" class="headerlink" title="2.3 插入部分数据"></a>2.3 插入部分数据</h2><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>没有添加数据的字段会使用NULL。</p><p>具体操作示例：</p><p>1.创建db2数据库，并使用。</p><pre><code>CREATE DATABASE db2;USE db2;</code></pre><p>2.创建完整学生信息表，包括学员的id，姓名，年龄，性别，家庭地址，电话号码，生日，数学成绩，英语成绩。</p><pre><code>CREATE TABLE  student(    id int,    name varchar(20),    age int,    sex char(1),    address varchar(200),    phone varchar(20),    birthday date,    math double,    english double);</code></pre><p>3.插入全部数据。</p><pre><code>INSERT INTO student VALUES (1,&#39;张三&#39;,19,&#39;男&#39;,&#39;北京市&#39;,&#39;18888888888&#39;,&#39;2010-12-12&#39;,92.5,32.5);</code></pre><p>4.插入部分数据，只往学生表中添加id, name, age, sex, address数据。</p><pre><code>INSERT INTO student (id,name,age,sex,address) values (2,&#39;李四&#39;,20,&#39;女&#39;,&#39;北京市&#39;);</code></pre><p>5.查看表中的数据。</p><pre><code>SELECT * FROM student;</code></pre><h2 id="2-4-蠕虫复制"><a href="#2-4-蠕虫复制" class="headerlink" title="2.4 蠕虫复制"></a>2.4 蠕虫复制</h2><p>在已有的数据基础之上，将原来的数据进行复制，插入到对应的表中。</p><p>语法格式：</p><pre><code>INSERT INTO 表名1 SELECT * FROM 表名2;</code></pre><p>作用:将表名2中的数据复制到表名1中。</p><p>具体操作示例：</p><p>1.创建student2表，student2结构和student1表结构一样；</p><pre><code>CREATE TABLE student2 LIKE student1;</code></pre><p>2.将student1表中的数据添加到student2表中；</p><pre><code>INSERT INTO student2 SELECT * FROM student1;</code></pre><p>3.如果只想复制student1表中name,age字段数据到student2表中使用如下格式。</p><pre><code>INSERT INTO student2(name,age) SELECT name,age FROM student1;</code></pre><h2 id="2-5-表数据的修改"><a href="#2-5-表数据的修改" class="headerlink" title="2.5 表数据的修改"></a>2.5 表数据的修改</h2><p>不带条件修改数据（全部修改）：</p><pre><code>UPDATE 表名 SET 字段名=值;</code></pre><p>带条件修改数据：</p><pre><code>UPDATE 表名 SET 字段名=值 WHERE 字段名=值;</code></pre><p>关键字说明：</p><pre><code>UPDATE: 修改数据SET: 修改哪些字段WHERE: 指定条件</code></pre><p>具体操作示例：</p><ul><li><p>不带条件修改数据，将所有的性别改成女：</p><p>  <code>UPDATE student SET sex=&#39;女&#39;;</code></p></li><li><p>带条件修改数据，将id号为2的学生性别改成男：</p><p>  <code>UPDATE student SET sex=&#39;男&#39; WHERE id=2;</code></p></li><li><p>一次修改多个列，把id为3的学生，年龄改成26岁，address改成北京</p><p>  <code>UPDATE student SET age=26,address=&#39;北京&#39; WHERE id=3;</code></p></li></ul><h2 id="2-6-表数据的删除"><a href="#2-6-表数据的删除" class="headerlink" title="2.6 表数据的删除"></a>2.6 表数据的删除</h2><p>不带条件删除数据（删除表里面的所有数据）：</p><pre><code>DELETE FROM 表名;</code></pre><p>带条件删除数据：</p><pre><code>DELETE FROM 表名 WHERE 字段名=值;</code></pre><p>具体操作示例：</p><ul><li><p>带条件删除数据，删除id为3的记录：</p><p>  <code>DELETE FROM student WHERE id=3;</code></p></li><li><p>不带条件删除数据,删除表中的所有数据：</p><p>  <code>DELETE FROM student;</code></p></li></ul><p>truncate也可以用来删除表记录</p><pre><code>TRUNCATE TABLE 表名;</code></pre><p><code>truncate</code>和<code>delete</code>的区别（面试题常问）：</p><ul><li><code>delete</code>是将表中的数据一条一条删除；</li><li><code>truncate</code>是将整个表摧毁，重新创建一个新的表（全空）,新的表结构和原来表结构一模一样。</li></ul><h1 id="3-DQL语句"><a href="#3-DQL语句" class="headerlink" title="3 DQL语句"></a>3 DQL语句</h1><h2 id="3-1-简单查询"><a href="#3-1-简单查询" class="headerlink" title="3.1 简单查询"></a>3.1 简单查询</h2><h3 id="3-1-1-查询表所有数据"><a href="#3-1-1-查询表所有数据" class="headerlink" title="3.1.1 查询表所有数据"></a>3.1.1 查询表所有数据</h3><p>使用 <code>*</code> 表示所有列：</p><pre><code>SELECT * FROM 表名;</code></pre><p>写出查询每列的名称（效率较高）：</p><pre><code>SELECT 字段名1, 字段名2, 字段名3, ... FROM 表名;</code></pre><p>具体操作示例：</p><pre><code>SELECT id,name,age,sex,address,phone,birthday,math,english FROM student;</code></pre><h3 id="3-1-2-查询指定列的数据"><a href="#3-1-2-查询指定列的数据" class="headerlink" title="3.1.2 查询指定列的数据"></a>3.1.2 查询指定列的数据</h3><p>多个列之间以逗号分隔：</p><pre><code>SELECT 字段名1, 字段名2... FROM 表名;</code></pre><p>具体操作示例：查询student表中的name和age列</p><pre><code>SELECT name, age FROM student;</code></pre><h3 id="3-1-3-别名查询"><a href="#3-1-3-别名查询" class="headerlink" title="3.1.3 别名查询"></a>3.1.3 别名查询</h3><pre><code>SELECT 字段名1 AS 别名, 字段名2 AS 别名... FROM 表名;</code></pre><ul><li>查询时给列、表指定别名需要使用AS关键字，AS可以省略不写；</li><li>使用别名的好处是方便观看和处理查询到的数据。</li></ul><p>具体操作示例：查询sudent表中name和age列，name列的别名为”姓名”，age列的别名为”年龄”。</p><pre><code>SELECT name AS 姓名, age AS 年龄 FROM student;</code></pre><h3 id="3-1-4-清除重复值"><a href="#3-1-4-清除重复值" class="headerlink" title="3.1.4 清除重复值"></a>3.1.4 清除重复值</h3><p>查询指定列并且结果不出现重复数据（字段名可以是一列可以是多列）：</p><pre><code>SELECT DISTINCT 字段名 FROM 表名;</code></pre><p>具体操作示例：查询name和age列并且结果不出现name和age都一样的重复数据</p><pre><code>SELECT DISTINCT name, age FROM student;</code></pre><h3 id="3-1-5-查询结果参与运算"><a href="#3-1-5-查询结果参与运算" class="headerlink" title="3.1.5 查询结果参与运算"></a>3.1.5 查询结果参与运算</h3><p>某列数据和固定值运算：</p><pre><code>SELECT 列名1 + 固定值 FROM 表名;</code></pre><p>某列数据和其他列数据参与运算：</p><pre><code>SELECT 列名1 + 列名2 FROM 表名;</code></pre><p>注意: 参与运算的必须是数值类型。</p><p>具体操作示例：</p><ul><li>查询的时候将数学和英语的成绩相加</li><li>让学员的年龄增加10岁</li></ul><p>实现：</p><p>1.查询 math + english 的和</p><pre><code>SELECT math + english FROM student;</code></pre><p>2.查询 math + english 的和使用别名”总成绩”</p><pre><code>SELECT math + english 总成绩 FROM student;</code></pre><p>3.查询所有列与 math + english（使用别名”总成绩”）</p><pre><code>SELECT *, math + english 总成绩 FROM student;</code></pre><p>4.查询姓名、年龄，将每个人的年龄增加10岁（不影响原来表中的数据）</p><pre><code>SELECT name, age + 10 FROM student;</code></pre><h2 id="3-2-Navicat的使用"><a href="#3-2-Navicat的使用" class="headerlink" title="3.2 Navicat的使用"></a>3.2 Navicat的使用</h2><p>Navicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。</p><p>Navicat是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。</p><p>具体示例：使用Navicat完成hero表(游戏中英雄角色表)</p><p>1.创建db数据库：右键新建数据库。</p><p>2.使用db数据库：双击。</p><p>3.创建hero表（在表上右键新建表添加字段和类型），表中包括：id，name，age，sex，attack(攻击力)，location(英雄的定位)，life(英雄的初始生命)，magic(英雄的初始魔法)，is_hot(是否是热门英雄)，grounding_date(英雄的上架日期)，max_score(英雄的最高评分)字段。然后ctrl+s保存并输入表名。</p><p>4.双击hero表，添加一条数据，对数据进行增删改操作。</p><p>注：还是要编写sql语句来实现功能不能单纯的依靠工具。</p><p>5.在数据库下的查询位置右键新建查询，即可输入sql语句，选中语句右键运行选择的即可进行运行操作。</p><h2 id="3-3-复杂条件查询"><a href="#3-3-复杂条件查询" class="headerlink" title="3.3 复杂条件查询"></a>3.3 复杂条件查询</h2><p>前面的查询是将所有数据都查询出来，但是有时候我们只想获取到满足条件的数据。</p><p>语法格式：</p><pre><code>SELECT 字段名 FROM 表名 WHERE 条件;</code></pre><p>流程：取出表中的每条数据，满足条件的记录就返回，不满足条件的记录不返回。</p><h3 id="3-3-1-比较运算符"><a href="#3-3-1-比较运算符" class="headerlink" title="3.3.1 比较运算符"></a>3.3.1 比较运算符</h3><p><code>&gt;</code>大于</p><p><code>&lt;</code>小于</p><p><code>&lt;=</code>小于等于</p><p><code>&gt;=</code>大于等于</p><p><code>=</code>等于</p><p><code>&lt;&gt;</code>、<code>!=</code>不等于</p><p>具体操作示例：</p><ul><li><p>查询攻击大于350的英雄</p><p>  <code>SELECT * FROM hero where attack&gt;350;</code></p></li><li><p>具体操作示例：查询评分小于12的英雄</p><p>  <code>SELECT * FROM hero WHERE max_score&lt;12;</code></p></li><li><p>查询定位为射手的英雄</p><p>  <code>SELECT * FROM hero WHERE location=&#39;射手&#39;;</code></p></li><li><p>查询不是热门的英雄，1表示热门，0表示非热门。</p><p>  <code>SELECT * FROM hero WHERE is_hot=0;</code></p><p>  <code>SELECT * FROM hero WHERE is_hot!=1;</code></p><p>  <code>SELECT * FROM hero WHERE is_hot&lt;&gt;1;</code></p></li></ul><h3 id="3-3-2-逻辑运算符"><a href="#3-3-2-逻辑运算符" class="headerlink" title="3.3.2 逻辑运算符"></a>3.3.2 逻辑运算符</h3><p><code>and</code> 多个条件同时满足</p><p><code>or</code> 多个条件其中一个满足</p><p><code>not</code> 不满足</p><p>具体操作示例：</p><ul><li><p>查询age大于35且生命值大于2500的英雄(两个条件同时满足)</p><p>  <code>SELECT * FROM hero WHERE age&gt;35 AND life&gt;2500;</code></p></li><li><p>查询age大于35或评分小于10的英雄(两个条件其中一个满足)</p><p>  <code>SELECT * FROM hero WHERE age&gt;35 OR max_score&lt;10;</code></p></li><li><p>查询id是1或3或5的英雄</p><p>  <code>SELECT * FROM hero WHERE id=1 OR id=3 OR id=5;</code></p></li></ul><p><code>in</code>关键字的语法格式：</p><pre><code>SELECT 字段名 FROM 表名 WHERE 字段 in (数据1, 数据2...);</code></pre><p><code>in</code>里面的每个数据都会作为一次条件，只要满足条件的就会显示。</p><p>具体操作示例：</p><ul><li><p>查询id是1或3或5的英雄</p><p>  <code>SELECT * FROM hero WHERE id in(1,3,5);</code></p></li><li><p>查询id不是1或3或5的英雄</p><p>  <code>SELECT * FROM hero WHERE id not in(1,3,5);</code></p></li></ul><h3 id="3-3-3-范围运算符"><a href="#3-3-3-范围运算符" class="headerlink" title="3.3.3 范围运算符"></a>3.3.3 范围运算符</h3><pre><code>BETWEEN 值1 AND 值2 </code></pre><p>表示从值1到值2范围，包头又包尾。</p><p>比如：</p><pre><code>age BETWEEN 35 AND 70</code></pre><p>相当于： </p><pre><code>age&gt;=35 AND age&lt;=70</code></pre><p>具体操作示例：查询英雄上架日期大于等于2013-01-01小于等于2017-01-01之间的英雄</p><pre><code>SELECT * FROM hero WHERE grounding_date BETWEEN &#39;2013-01-01&#39; AND &#39;2017-01-01&#39;;SELECT * FROM hero WHERE grounding_date &gt;=&#39;2013-01-01&#39;  AND grounding_date&lt;=&#39;2017-01-01&#39;;</code></pre><h3 id="3-3-4-模糊查询"><a href="#3-3-4-模糊查询" class="headerlink" title="3.3.4 模糊查询"></a>3.3.4 模糊查询</h3><p>用<code>LIKE</code>表示模糊查询</p><pre><code>SELECT * FROM 表名 WHERE 字段名 LIKE &#39;通配符字符串&#39;;</code></pre><p>这样，满足通配符字符串规则的数据就会显示出来。</p><p>MySQL通配符有两个：</p><p><code>%</code>: 表示0个或多个字符(任意个字符)</p><p><code>_</code>: 表示一个字符</p><p>具体操作示例：</p><ul><li><p>查询姓孙的英雄</p><p>  <code>SELECT * FROM hero WHERE name LIKE &#39;孙%&#39;;</code></p></li><li><p>查询姓名中包含’孙’字的英雄(前后都可以匹配任意个字符)</p><p>  <code>SELECT * FROM hero WHERE name LIKE &#39;%孙%&#39;;</code></p></li><li><p>查询姓孙，且姓名有三个字的英雄</p><p>  <code>SELECT * FROM hero WHERE name LIKE &#39;孙__&#39;;</code></p></li></ul><h3 id="3-3-5-结果排序"><a href="#3-3-5-结果排序" class="headerlink" title="3.3.5 结果排序"></a>3.3.5 结果排序</h3><p>通过<code>ORDER BY</code>子句，可以将查询出的结果进行排序(排序只是显示方式，不会影响数据库中数据的顺序)。</p><p>语法：</p><pre><code>SELECT 字段名 FROM 表名 WHERE 字段=值 ORDER BY 字段名 [ASC|DESC];</code></pre><p><code>ASC</code>: 升序, 默认是升序</p><p><code>DESC</code>: 降序</p><p>1.单列排序：使用一个字段排序</p><p>具体操作示例：查询年龄小于等于35岁的英雄，按照年龄升序排列</p><pre><code>SELECT * FROM hero WHERE age&lt;=35 ORDER BY age ASC;</code></pre><p>2.组合排序：先按第一个字段进行排序，如果第一个字段相同，才按第二个字段进行排序，依次类推。</p><pre><code>SELECT 字段名 FROM 表名 WHERE 字段=值 ORDER BY 字段名1 [ASC|DESC], 字段名2 [ASC|DESC];</code></pre><p>具体操作示例：查询年龄小于等于35岁的英雄，按照年龄升序排列，如果年龄相同按照生命的降序排列</p><pre><code>SELECT * FROM hero WHERE age&lt;=35 ORDER BY age ASC,life DESC;</code></pre><h3 id="3-3-6-聚合函数"><a href="#3-3-6-聚合函数" class="headerlink" title="3.3.6 聚合函数"></a>3.3.6 聚合函数</h3><p>之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个结果值。注意，聚合函数会忽略空值NULL。</p><p>五个聚合函数：</p><p><code>count</code>： 统计指定列记录数，记录为NULL的不统计</p><p><code>sum</code>： 计算指定列的数值和，如果不是数值类型，那么计算结果为0</p><p><code>max</code>： 计算指定列的最大值</p><p><code>min</code>： 计算指定列的最小值</p><p><code>avg</code>： 计算指定列的平均值，如果不是数值类型，那么计算结果为0</p><p>聚合函数的使用：写在SQL语句 <code>SELECT</code> 后 <code>字段名</code> 的地方</p><pre><code>SELECT 字段名... FROM 表名;SELECT COUNT(age) FROM 表名;</code></pre><p>具体操作示例：</p><ul><li><p>查询英雄总数</p><p>  <code>SELECT COUNT(max_score) FROM hero</code></p><p>  因为对于NULL的记录不会统计，所以使用某一列不够保险。</p><p>  即，只要使用全部字段作为衡量标准就不会有遗漏的错误统计出现：</p><p>  <code>SELECT COUNT(*) FROM hero</code></p></li><li><p>查询年龄大于35的英雄总数</p><p>  <code>SELECT COUNT(*) FROM hero WHERE age&gt;35;</code></p></li><li><p>查询所用英雄的总评分</p><p>  <code>SELECT SUM(max_score) FROM hero</code></p></li><li><p>查询英雄评分的平均分</p><p>  <code>SELECT AVG(max_score) FROM hero</code></p></li><li><p>查询英雄评分的最高分</p><p>  <code>SELECT MAX(max_score) FROM hero</code></p></li><li><p>查询英雄评分的最低分</p><p>  <code>SELECT MIN(max_score) FROM hero</code></p></li></ul><h3 id="3-3-6-分组查询"><a href="#3-3-6-分组查询" class="headerlink" title="3.3.6 分组查询"></a>3.3.6 分组查询</h3><p>分组查询是指使用 <code>GROUP BY</code> 语句对查询信息进行分组，相同数据作为一组:</p><pre><code>SELECT 字段1,字段2... FROM 表名 GROUP BY 分组字段 [HAVING 条件];</code></pre><p>GROUP BY是通过将分组字段结果中相同内容作为一组来进行分组。</p><pre><code>SELECT * FROM hero GROUP BY sex;</code></pre><p>上面这句话会将sex相同的数据作为一组，但是只会返回每组的第一条数据，没有任何意义。</p><p>分组的目的就是为了统计，一般分组会跟聚合函数一起使用。</p><p>分组后聚合函数的作用：不是操作所有数据，而是操作一组数据。例如求男生组生命总和及女生组生命总和的语句如下。</p><pre><code>SELECT SUM(life) FROM hero GROUP BY sex</code></pre><p>注意事项：当我们使用某个字段分组,在查询的时候也需要将这个字段查询出来,否则看不到数据属于哪组的,正确写法如下。</p><pre><code>SELECT SUM(life),sex FROM hero GROUP BY sex</code></pre><p>具体操作示例：</p><ul><li><p>查询年龄小于30岁的人,按性别分组,统计每组的人数</p><p>   1.先查询年龄大于30岁的人；2.再分组；3.最后统计每组的人数。</p><p>  <code>SELECT sex,count(*) FROM hero WHERE age&lt;30 GROUP BY sex;</code></p></li><li><p>查询年龄小于30岁的人,按性别分组,统计每组的人数,并只显示性别人数大于2的数据</p><p>  其中，<code>并只显示性别人数&gt;2的数据</code>属于分组后的条件,对于分组后的条件需要使用having语句。</p><p>  <code>SELECT sex,count(*) FROM hero WHERE age&lt;30 GROUP BY sex HAVING COUNT(*)&gt;2;</code></p><p>  1.先查询年龄大于30岁的人；2.再分组；3.统计每组的人数；4.显示性别人数大于2的数据。</p></li></ul><p><code>having</code>与<code>where</code>的区别（面试题常问）：</p><ul><li><code>having</code>是在分组后对数据进行过滤</li><li><code>where</code>是在分组前对数据进行过滤</li><li><code>having</code>后面可以使用聚合函数</li><li><code>where</code>后面不可以使用聚合函数</li></ul><h3 id="3-3-7-Limit分页"><a href="#3-3-7-Limit分页" class="headerlink" title="3.3.7 Limit分页"></a>3.3.7 Limit分页</h3><p>LIMIT的作用是限制查询记录的条数：</p><pre><code>SELECT *|字段列表 [as 别名] FROM 表名 [WHERE子句] [GROUP BY子句][HAVING子句][ORDER BY子句][LIMIT子句];</code></pre><p>思考：limit子句为什么排在最后？</p><p>因为前面所有的限制条件都处理完了，只剩下显示多少条记录的问题了！</p><p>LIMIT语法格式：</p><pre><code>LIMIT offset,length; 或者 LIMIT length;</code></pre><p><code>offset</code>是指偏移量，可以认为是跳过的记录数量，默认为0；</p><p><code>length</code>是指需要显示的总记录数，即要查几条记录。</p><p>具体操作示例：查询hero表中数据，从第三条开始显示，显示6条，我们可以认为跳过前面2条，取6条数据。</p><pre><code>SELECT * FROM student LIMIT 2,6;</code></pre><p><strong>LIMIT的使用场景</strong>：<strong>分页</strong></p><p>比如我们登录京东，淘宝，返回的商品信息可能有几万条，不是一次全部显示出来。是一页显示固定的条数。</p><p>假设我们每页显示5条记录的方式来分页，SQL语句如下：</p><pre><code>-- 每页显示5条-- 第一页： LIMIT 0,5;   跳过0条，显示5条-- 第二页： LIMIT 5,5;   跳过5条，显示5条-- 第三页： LIMIT 10,5;  跳过10条，显示5条SELECT * FROM hero LIMIT 0,5;SELECT * FROM hero LIMIT 5,5;SELECT * FROM hero LIMIT 10,5;</code></pre><p>注意：</p><p>1.如果第一个参数是0可以简写：</p><pre><code>SELECT * FROM student3 LIMIT 0,5;SELECT * FROM student3 LIMIT 5;</code></pre><p>2.<code>LIMIT 10，5;</code> 不够5条，即最后一页有多少显示多少。</p><h1 id="4-数据库约束"><a href="#4-数据库约束" class="headerlink" title="4 数据库约束"></a>4 数据库约束</h1><p>对表中的数据进行进一步的限制，保证数据的正确性、有效性和完整性。</p><p>约束种类：</p><p><code>PRIMARY KEY</code>: 主键</p><p><code>UNIQUE</code>: 唯一</p><p><code>NOT NULL</code>: 非空</p><p><code>DEFAULT</code>: 默认</p><p><code>FOREIGN KEY</code>: 外键</p><h2 id="4-1-主键约束"><a href="#4-1-主键约束" class="headerlink" title="4.1 主键约束"></a>4.1 主键约束</h2><h3 id="4-1-1-主键的作用"><a href="#4-1-1-主键的作用" class="headerlink" title="4.1.1 主键的作用"></a>4.1.1 主键的作用</h3><p><strong>用来唯一标识一条记录</strong>，每个表都应该有一个主键，并且每个表只能有一个主键。</p><p>有些记录的 <code>name,age,sex</code> 字段的值都一样时,那么就没法区分这些数据,造成数据库的记录不唯一,这样就不方便管理数据。</p><p>哪个字段应该作为表的主键？</p><p>​通常不用业务字段作为主键，单独给每张表设计一个 <code>id</code> 的字段，把 <code>id</code> 作为主键。主键是给数据库和程序使用的，不是给最终的客户使用的。所以主键有没有含义没有关系，只要不重复，非空就行。</p><h3 id="4-1-2-创建主键"><a href="#4-1-2-创建主键" class="headerlink" title="4.1.2 创建主键"></a>4.1.2 创建主键</h3><p>主键：<code>PRIMARY KEY</code></p><p>主键的特点：</p><ul><li>主键必须包含唯一的值</li><li>主键列不能包含NULL值</li></ul><p>创建主键方式：在创建表的时候给字段添加主键，或者直接在Navicat表的设计中点击钥匙。</p><pre><code>字段名 字段类型 PRIMARY KEY</code></pre><p>具体操作示例：</p><p>1.创建英雄表hero1, 包含字段(<code>id, name, age</code>)将 <code>id</code> 做为主键（主键在Navicat中会显示一个小钥匙）</p><pre><code>CREATE TABLE hero1(    id int PRIMARY Key,    name varchar(20),    age int);</code></pre><p>2.添加数据</p><pre><code>INSERT INTO hero1 (id, NAME) VALUES (1, &#39;盾山&#39;);INSERT INTO hero1 (id, NAME) VALUES (2, &#39;梦琪&#39;);INSERT INTO hero1 (id, NAME) VALUES (3, &#39;鲁班&#39;);INSERT INTO hero1 (id, NAME) VALUES (4, &#39;白起&#39;);</code></pre><p>3.再插入一个<code>id</code>为1的英雄，即插入重复的主键值</p><pre><code>INSERT INTO hero1 (id, NAME) VALUES (1, &#39;盾山&#39;);-- 主键是唯一的不能重复，报错Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;</code></pre><p>4.试着插入一个<code>id</code>为NULL的英雄，即插入NULL的主键值</p><pre><code>INSERT INTO hero1 (id, NAME) VALUES (NULL, &#39;蔡文姬&#39;);-- 主键是不能为空的，报错Column &#39;id&#39; cannot be null</code></pre><h3 id="4-1-3-删除主键"><a href="#4-1-3-删除主键" class="headerlink" title="4.1.3 删除主键"></a>4.1.3 删除主键</h3><pre><code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></pre><p>具体操作示例：删除hero1表的主键</p><pre><code>ALTER TABLE hero1 DROP PRIMARY KEY;</code></pre><h3 id="4-1-4-主键自增"><a href="#4-1-4-主键自增" class="headerlink" title="4.1.4 主键自增"></a>4.1.4 主键自增</h3><p>​主键如果让我们自己添加很有可能重复，我们通常希望在每次插入新记录时，数据库自动生成主键字段的值。</p><pre><code>AUTO_INCREMENT-- 表示自动增长(字段类型必须是整数类型)</code></pre><p>具体操作示例：</p><p>1.创建英雄表hero2, 包含字段(<code>id, name, age</code>)将 <code>id</code> 做为主键并自动增长</p><pre><code>CREATE TABLE hero2(    id int PRIMARY Key AUTO_INCREMENT,    name varchar(20),    age int);</code></pre><p>2.插入数据</p><pre><code>INSERT INTO hero2 (NAME, age) VALUES (&#39;猪八戒&#39;, 22);INSERT INTO hero2 (NAME, age) VALUES (&#39;关羽&#39;, 26);INSERT INTO hero2 (NAME, age) VALUES (&#39;诸葛亮&#39;, 25);INSERT INTO hero2 (NAME, age) VALUES (&#39;孙膑&#39;, 20);-- 不维护id字段，主键默认从1开始自动增长</code></pre><p><strong>扩展</strong></p><p>默认地 <code>AUTO_INCREMENT</code> 的开始值是1，如果希望修改起始值,请使用下列SQL语法。</p><pre><code>ALTER TABLE 表名 AUTO_INCREMENT=起始值;</code></pre><p><code>DELETE</code>和<code>TRUNCATE</code>的区别(面试常问)：</p><ul><li><code>DELETE</code> 删除表中的数据，不会摧毁表，不重置AUTO_INCREMENT的值，接着之前的自增</li><li><code>TRUNCATE</code> 摧毁表，重建表，AUTO_INCREMENT重置为1开始自增</li></ul><h2 id="4-2-唯一约束"><a href="#4-2-唯一约束" class="headerlink" title="4.2 唯一约束"></a>4.2 唯一约束</h2><p>在这张表中这个字段的值不能重复，比如身份证号手机号等信息。</p><p>唯一约束的基本语法格式：</p><pre><code>字段名 字段类型 UNIQUE</code></pre><p>具体实现步骤：</p><p>1.创建英雄表hero3, 包含字段(<code>id, name</code>), <code>name</code> 这一列设置唯一约束,不能出现同名的英雄。</p><pre><code>CREATE TABLE hero3 (    id INT,    NAME VARCHAR(20) UNIQUE);</code></pre><p>2.添加英雄</p><pre><code>INSERT INTO hero3 VALUES (1, &#39;貂蝉&#39;);INSERT INTO hero3 VALUES (2, &#39;西施&#39;);INSERT INTO hero3 VALUES (3, &#39;王昭君&#39;);INSERT INTO hero3 VALUES (4, &#39;杨玉环&#39;);INSERT INTO hero3 VALUES (5, &#39;貂蝉&#39;);-- 插入相同的名字出现name重复，报错Duplicate entry &#39;貂蝉&#39; for key &#39;name&#39;INSERT INTO hero3 VALUES (5, NULL);INSERT INTO hero3 VALUES (6, NULL);-- 因为null是没有值，所以不存在重复的问题，可以插入多个NULL</code></pre><h2 id="4-3-非空约束"><a href="#4-3-非空约束" class="headerlink" title="4.3 非空约束"></a>4.3 非空约束</h2><p>表示这个字段必须设置值,不能是NULL。</p><p>非空约束的基本语法格式：</p><pre><code>字段名 字段类型 NOT NULL</code></pre><p>具体操作步骤：</p><p>1.创建表英雄表hero4, 包含字段(<code>id,name,gender</code>)其中 <code>name</code> 不能为NULL</p><pre><code>CREATE TABLE hero4 (    id INT,    NAME VARCHAR(20) UNIQUE NOT NULL,    gender CHAR(2));</code></pre><p>2.添加一条完整的记录</p><pre><code>INSERT INTO hero4 VALUES (1, &#39;扁鹊&#39;, &#39;男&#39;);INSERT INTO hero4 VALUES (2, &#39;镜&#39;, &#39;男&#39;);INSERT INTO hero4 VALUES (3, &#39;恺&#39;, &#39;男&#39;);INSERT INTO hero4 VALUES (4, &#39;貂蝉&#39;, &#39;男&#39;);INSERT INTO hero4 VALUES (5, NULL, &#39;男&#39;);-- 姓名不赋值报错: Column &#39;name&#39; cannot be null</code></pre><h2 id="4-4-默认值约束"><a href="#4-4-默认值约束" class="headerlink" title="4.4 默认值约束"></a>4.4 默认值约束</h2><p>往表中添加数据时,如果不指定这个字段的数据,就使用默认值。</p><p>默认值格式：</p><pre><code>字段名 字段类型 DEFAULT 默认值</code></pre><p>具体操作示例：</p><p>1.创建一个英雄表 hero5，包含字段(<code>id,name,location</code>)，默认的定位是射手</p><pre><code>CREATE TABLE hero5 (    id INT,    NAME VARCHAR(20),    location VARCHAR(50) DEFAULT &#39;射手&#39;);</code></pre><p>2.添加一条记录,使用默认地址</p><pre><code>INSERT INTO hero5 (id, NAME) VALUES (1, &#39;后羿&#39;);</code></pre><p>3.添加一条记录,不使用默认地址</p><pre><code>INSERT INTO hero5 VALUES (2, &#39;兰陵王&#39;, &#39;刺客&#39;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语言 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像中的拉普拉斯平滑</title>
      <link href="/2021/07/16/My-Post13/"/>
      <url>/2021/07/16/My-Post13/</url>
      
        <content type="html"><![CDATA[<h1 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h1><p>平滑的目的也是正则化的目的之一，它是针对参数w而言的，本质上就是要使得w的变化不要那么剧烈，有如下数学模型（假设最小化J）：</p> \[J(w) = {\sum\limits_{i = 1}^N {\left( {{y_i} - {w^T}{x_i}} \right)} ^2} + \lambda \left\| w \right\|_2^2\] <p>式1中，左侧是一个典型的线性回归模型，(xi,yi)为实际观测值，w是估计的参数，右侧就是一个正则化项。可以直观的感受到，正则化项实际上起到了限制参数w的“变化程度或变化幅值”的作用，具体来说，它可以令w的任何一个分量相比较于剩余分量变化程度保持一致，不至于出现变化特别明显的分量。直接的作用就是防止模型“过拟合”，提高了模型的泛化性能。</p><h1 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a>拉普拉斯平滑</h1><p><strong>定义：</strong></p><p>假设f是定义在d维子空间中的一个实函数，该子空间上的拉普拉斯算子和拉普拉斯代价函数分别为：</p> \[Lf(t) = \sum\limits_{i = 1}^d {\frac{{{\partial ^2}f}}{{\partial t_i^2}}} \]  \[J(f) = \int\limits_{\Omega  \in {R^d}} {{{(Lf(t))}^2}dt} \] <p>我们想象一幅图像如果含有噪声，或者色彩变化剧烈，说明其不够平滑，上式中的算子就好比一个“小刷子”，不仅可以刷去“小黑点（噪声的一种）”，也可以模糊图像。而式中的代价函数就好比用这个“小刷子”去刷一整幅图像，使得整幅图像变得平滑。</p><p><strong>应用：</strong></p><p>当式2和式3中的d=2（图像就是2维的），并且积分号变成求和号时（连续变为离散），就是拉普拉斯平滑在图像上的应用。</p><h1 id="拉普拉斯惩罚"><a href="#拉普拉斯惩罚" class="headerlink" title="拉普拉斯惩罚"></a>拉普拉斯惩罚</h1><p>机器学习中，大部分算法直接将图像（假设为M*N）按行或者列拉成向量，这样肯定会损失结构化信息。</p><p><strong>结构化信息</strong>是什么？</p><p>图像中的像素点和它周围像素点之间的“大小依赖关系”，就是空间结构信息，如果在低维空间中这种“大小依赖关系”也能够保持，那么就相当于保持了图像的空间结构信息。</p><p>这种信息属于先验信息，<strong>NFL定理</strong>（西瓜书P9“没有免费的午餐”定理）说的很清楚：能够尽可能利用先验信息的学习算法才是好算法。看来，空间结构信息的破坏，会降低算法的“品味”。通过拉普拉斯惩罚，来补偿图像拉成向量x（M*N维）后失去的结构信息，公式如下：</p> \[{x_{new}} = \Delta *x\] <p>其中，</p> \[\Delta  = {D_1} \otimes {I_2} + {I_1} \otimes {D_2}\]  \[{D_1},{I_1} \in {R^{M*M}}\]  \[{D_2},{I_2} \in {R^{N*N}}\] <p>式中，<strong>D1和D2均为拉普拉斯算子</strong>，而I1，I2就是单位矩阵，的乘法是Kronecke积，相当于将乘号右边的每个元素替换成为左边矩阵数乘对应元素，如果A是一个 m x n 的矩阵，而B是一个 p x q 的矩阵，Kronecke积则是一个 mp x nq 的矩阵。</p><p>上述公式实际上起到的效果是，求一个矩阵中每个元素的水平方向和垂直方向的二阶差分之和，这个矩阵在这里可以被看成参数w的矩阵形式（按列reshape）。</p><p>进一步，如果我们对一个线性回归模型加上拉普拉斯惩罚，模型就会变为如下形式:</p> \[J(w) = \sum\limits_{i = 1}^N {{{({y_i} - {w^T}{x_i})}^2} + \lambda \left\| {\Delta  \cdot w} \right\|} _2^2\] <p>这个模型就是一个加了正则化项（即加了拉普拉斯惩罚）的线性回归模型.</p><p><strong>拉普拉斯惩罚</strong>的具体形式为：</p> \[\Delta  = {D_1} \otimes {I_2} + {I_1} \otimes {D_2}\] <p>这样的话，假设图像x为M×N矩阵，那么对应的参数向量w就为M×N维的列向量，当算子采用<strong>修正的Neuman算子</strong>时（如下式所示），上面的拉普拉斯惩罚公式第一项起到的作用就是保持图像的列方向的空间结构（列方向上，相邻像素的大小关系保持不变），第二项起到的作用就是提取行方向的空间结构（行方向上，相邻像素的大小关系保持不变），两项加在一起，保持的自然就是图像整体的空间结构了。</p> \[\left[ {\begin{array}{*{20}{c}}{ - 1}&1&{}&{}&{}\\1&{ - 2}&1&{}&{}\\{}& \cdot & \cdot & \cdot &{}\\{}&{}&1&{ - 2}&1\\{}&{}&{}&1&{ - 1}\end{array}} \right]\] <p>拉普拉斯惩罚使得模型更加平滑，比简单的2范数（岭回归）要好，因为拉普拉斯惩罚在参数向量w（M*N维）上施加平滑约束,也就是让相邻的分量尽可能的相等，这样的话，w与一个图像（肯定是拉成向量之后的图像）相乘，图像像素与周围像素的大小关系得以保持，也就使得图像的空间结构信息得到保持。</p><p>拉普拉斯惩罚常被用于PCA，LDA，LPP，NPE等子空间学习算法的改造上面，一般会使算法性能得到提升。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 正则化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于机器学习的Udacity无人驾驶仿真</title>
      <link href="/2021/05/31/My-Post11/"/>
      <url>/2021/05/31/My-Post11/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h1><h2 id="1-1项目要求"><a href="#1-1项目要求" class="headerlink" title="1.1项目要求"></a>1.1项目要求</h2><p>自动驾驶又称无人驾驶、轮式机器人，是一种通过电脑实现无人驾驶的技术（行为）。自动驾驶依靠人工智能、计算机视觉、雷达、监控装置和全球定位系统，不需要人类主动操作，汽车自动安全地行驶。自动驾驶是目前最热门的也是最有突破性的技术之一，其中人工智能是关键技术之一，又叫深度学习，是自动驾驶的核心。</p><p>Udacity由Google公司x实验室创始人，称作无人驾驶之父的Sebastian Thrun（塞巴斯蒂安·史朗）创立，被人们称作“云端大学”。开设诸如“无人驾驶、大数据、人工智能”等高端前沿课程，授予的学位叫“Nanodegree（纳米学位）”。</p><h2 id="1-2项目内容及方案"><a href="#1-2项目内容及方案" class="headerlink" title="1.2项目内容及方案"></a>1.2项目内容及方案</h2><p>本项目基于深度神经网络，构建一个Udacity无人驾驶仿真环境下的无人驾驶系统。</p><p>Udacity无人驾驶仿真环境是Udacity公司为自己的学员设计的，针对无人驾驶项目的模拟环境，验证代码的有效性。该仿真环境部分免费，本项目用的就是免费部分。项目分四步实现。</p><p>第一步，使用Udacity模拟器采集数据；</p><p>第二步，对采集到的图像数据进行预处理；</p><p>第三步，使用深度卷积神经网络设计、建立、训练自动驾驶模型；</p><p>第四步，使用Udacity模拟器自动驾驶车辆，验证模型。</p><p>项目用到的第三方库包括：opencv，pandas，pillow，keras，scikit-learn，tensorflow，Python-socketio，flask，Flask-SocketIO，Python-engineio，eventlet。</p><h1 id="2-项目原理"><a href="#2-项目原理" class="headerlink" title="2 项目原理"></a>2 项目原理</h1><h2 id="2-1视频图像采集"><a href="#2-1视频图像采集" class="headerlink" title="2.1视频图像采集"></a>2.1视频图像采集</h2><p>本项目使用Udacity模拟器采集视频图像数据，这里直接使用别人采集好的原始数据。原始数据提供了由安装在车辆前方的左、中、右摄像机拍摄的图片，及车辆在这个时刻的转角（方向、油门、刹车、速度），保存在driving_log.csv文件中。本项目会利用这些数据，训练一个深度学习模型模仿车辆的驾驶行为，从而达到自动控制车辆的效果。为了简单、方便，模型只训练一个图像，即模型只输入一个图像，只会预测汽车转向角（只有一个输出），速度采用限速。</p><h2 id="2-2图像数据预处理"><a href="#2-2图像数据预处理" class="headerlink" title="2.2图像数据预处理"></a>2.2图像数据预处理</h2><p>首先在左、中、右三张图片中随机选择一张图片，然后使用Python Opencv库中的图像处理函数对数据集做预处理（视频图像预处理）。考虑复杂的现实环境，如天气、拍摄角度、自然光照、遮挡、摄像机自身原因造成的图像模糊、歪斜或缺损的情况。图像预处理包括选择图像、翻转、平移、阴影、亮度调节、预处理。</p><p>这些图像预处理方法都是随机执行的，确保后期训练的模型具有较强的泛化能力。其中，图像翻转使用cv2.flip函数；图片平移使用仿射变换函数cv2.warpAffine；阴影遮挡方法为先将图像转换为HLS格式，对亮度（L）进行遮挡后再转换为RGB格式；亮度调节方法为将图像转换为HSV格式，对明度（V）进行调整；然后截取图像，去掉机盖和天空，调整图像尺寸并转换为YUV格式（一种颜色编码方法，常使用在各个视频处理组件中）。</p><h2 id="2-3设计、建立、训练深度学习模型"><a href="#2-3设计、建立、训练深度学习模型" class="headerlink" title="2.3设计、建立、训练深度学习模型"></a>2.3设计、建立、训练深度学习模型</h2><p>该阶段的主要内容如下：</p><p>（1）调用argparse模块，用于向模型传递数据。首先创建一个解析对象，然后向该对象中添加你要关注的命令行参数和选项，进而执行 parse_args() 进行解析。</p><p>（2）导入数据（清单），将存储在硬盘中的数据（清单）导入内存。首先使用pd.read_csv函数读取CSV文件，获取需要的数据，然后调用train_test_split函数划分训练集和测试集。</p><p>（3）编写数据生成器，逐批生成数据，分批次向模型送入数据。对随机抽取的图像数据，20%的情况会调用图像预处理程序对图像进行随机预处理，80%的情况会直接获取中间图像。这里使用yield而不用return，目的是使程序从上一次停止的地方继续执行，抽过的数据就不会再抽了。</p><p>（4）利用Keras搭建CNN的一个顺序模型，本项目使用一个现成的模型。模型含有5个卷积层（Conv2D），输入图像是一个3通道的彩色图像，图像像素值首先会被归一化（Lambda）为0~1之间的数值；然后通过5个卷积层（Conv2D），1个扁平层（Flatten），3个全连接层（Dense）的作用后，输出方向盘角度值，这是一个回归问题（该网络被称为nvidia net）。</p><p>（5）将数据送入模型进行训练，送入数据的方式有很多种，这里使用model.fit_generator()的方式送数据。首先使用model.compile()函数设置好模型训练策略，这里使用Adam优化算法（学习率设置为0.0001）和mse损失函数。model.fit_generator()的实现方法是利用生成器，分批次向模型送入数据，生成器与模型并行运行，可以有效节省单次内存的消耗。保存训练得到的模型参数，用于后续的模型验证。</p><h2 id="2-4验证模型"><a href="#2-4验证模型" class="headerlink" title="2.4验证模型"></a>2.4验证模型</h2><p>项目使用socketio和Flask，实现web服务器和web应用程序之间的通信进而对模型进行验证。其中socketio是针对Python开发的基于socket的web服务器，其中，socket为服务器和应用程序提供了双向通信机制，意味着服务器可以推送消息给应用程序。Flask是基于python的web应用程序架构。eventlet是一个网络通信应用程序，用来处理多线程。</p><p>首先，定义（建立）socketio服务器，可看做建立了一个插座。然后，采用Flask做应用程序，相当于插头。进而，将服务器与应用程序打包成WSGI（Web Server Gateway Interface），相当于把插座与插头连接在一起。WSGI指定了web服务器和Python web应用或web框架之间的标准接口，是 python web 开发的标准，规定了各自使用的接口和功能，以便二者互相配合实现连接。 </p><p>连接过程本项目用到的事件包括connect event、disconnect event和telemetry event，这三个事件的表示分别是：connect event表示服务器（Python程序）与客户端（模拟器）连接成功；disconnect event表示服务器（Python程序）与客户端（模拟器）断开连接；在小车运动过程中，会通过telemetry event模拟器发送小车当前的转向角、油门、车速，以及当前摄像机拍摄的照片，要控制仿真器中小车的运动，需要向仿真器发送如下两个参数：steering_angle：转向角，throttle：油门。</p><p>设置好连接事件及相关响应函数后，加载前面训练好的模型参数文件，使用WSGI托管运行，打开Udacity模拟器点击自动驾驶，就可以看到汽车在自动向前行驶并且可以走相当一段长的距离。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 无人驾驶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于OpenCV的人脸识别签到系统</title>
      <link href="/2021/05/22/My-Post10/"/>
      <url>/2021/05/22/My-Post10/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h1><h2 id="1-1项目要求"><a href="#1-1项目要求" class="headerlink" title="1.1项目要求"></a>1.1项目要求</h2><p>当今社会，科学技术呈现着井喷式的发展情况，新理论的不断提出及新技术的实时应用，给人们的生活带来了日新月异的变化。在这些新技术新应用中，物联网、人工智能、大数据等名词被人们纷纷提起，产业领域的智能化产品层出不穷，其中人脸识别就是一个典型应用。</p><p>本项目构建一个基于OpenCV + Python的人脸识别上课签到系统。人脸识别是指将一个需要识别的人脸和人脸库中的某个人脸对应起来（类似于指纹识别），目的是完成识别功能。人脸检测是在一张图片中把人脸定位出来，完成的是搜寻的功能。</p><h2 id="1-2项目内容及方案"><a href="#1-2项目内容及方案" class="headerlink" title="1.2项目内容及方案"></a>1.2项目内容及方案</h2><p>项目用到的第三方库包括：opencv-python、opencv-contrib-python、pillow、tk、xlrd、xlwt、xlutils。OpenCV是一个开源的计算机视觉库，应用领域非常广泛，包括图像拼接、图像降噪、产品质检、人机交互、人脸识别、动作识别、动作跟踪、无人驾驶等。此外，OpenCV还提供了机器学习模块，可以使用正态贝叶斯、K近邻、支持向量机、决策树、随机森林、人工神经网络等机器学习算法。关于人脸识别，OpenCV提供了三种人脸识别方法，分别是LBPH方法、EigenFishfaces方法、Fisherfaces方法。</p><p>本项目采用LBPH方法，分四步实现：</p><p>第一步，通过调用摄像头进行人脸图像采集，建立人脸图像库。</p><p>第二步，对人脸图像库中的人脸图像提取特征信息（LBPH），并训练成模型，存储起来形成特征库。</p><p>第三步，开启摄像头实时跟踪人脸，获取人脸特征信息，然后将获取的人脸特征信息与学习阶段建立的特征库进行比对，将识别的信息呈现在画面中。</p><p>第四步，设计人脸识别签到系统的GUI界面。</p><h1 id="2-项目原理"><a href="#2-项目原理" class="headerlink" title="2 项目原理"></a>2 项目原理</h1><h2 id="2-1人脸采集"><a href="#2-1人脸采集" class="headerlink" title="2.1人脸采集"></a>2.1人脸采集</h2><p>人脸采集用到了OpenCV库和xlrd库。首先使用xlrd.open_workbook函数读取考勤记录表，使用sheet_by_index函数指定到索引值对应的表格，进而使用col_values获取表格第二列的值，表格第二列对应学生学号，当学生输入学号之后，将该学号与前面获取的所有学号进行比对，检查输入是否有误。</p><p>使用cv2.VideoCapture函数打开摄像头，使用cv2.CascadeClassifier加载预训练好的分类器模型haarcascade_frontalface_default.xml。当摄像头打开成功后，读取摄像头拍摄到的图像，将读回的图像转换成灰度图像，利用预训练好的分类器模型，使用detectMultiScale函数检测灰度图像，判断图像中是否有人脸。</p><p>如果检测到人脸在图像中用矩形框将人脸框出，并且在图像上添加关于按键操作的文本内容。监控键盘，如果点击了键盘上的‘S’按键就保存截取到的人脸图像并给图片命名，可以连续保存多张图片，输出采集的图片是第几张，方便查看，如果点击了键盘上的‘Esc’按键则退出采集，并最终输出学生学号和采集到的人脸图片总数。该过程中采集到的所有人脸图片全部都按照名字和学号命名好保存在了dataset文件夹中。</p><h2 id="2-2提取人脸特征，建立特征库"><a href="#2-2提取人脸特征，建立特征库" class="headerlink" title="2.2提取人脸特征，建立特征库"></a>2.2提取人脸特征，建立特征库</h2><p>该步骤使用cv2.face.LBPHFaceRecognizer_create()函数提取人脸特征。对上一步骤dataset文件夹中命名并保存好的图片进行重新整理，首先获取文件夹中的图片清单，遍历所有图片，将图片转换成灰度图像，进而转换为数组类型，利用预训练好的关于人脸识别的分类器模型，使用detectMultiScale函数检测灰度图像，判断图像中是否有人脸。</p><p>如果检测到人脸，将人脸数据和对应的学号数据分别存放在两个数组中，将人脸数据使用LBPH方法进行训练，进而提取脸部特征，保存训练好的文件trainer.yml，从而建立了一个前文采集到的人脸的特征库。这里的dataset包含全班同学采集到的人脸照片，所以最终训练好的特征库应该可以识别班里所有同学的脸。</p><h2 id="2-3人脸比对并签到"><a href="#2-3人脸比对并签到" class="headerlink" title="2.3人脸比对并签到"></a>2.3人脸比对并签到</h2><p>打开摄像头，加载预训练好的关于人脸识别的分类器模型，读取上一步骤保存好的训练文件，即读取提取到的人脸特征库。打开摄像头，读取摄像头拍摄到的图像，将读回的图像转换成灰度图像，利用预训练好的分类器模型，使用detectMultiScale函数检测灰度图像，判断图像中是否有人脸。如果检测到人脸在图像中用矩形框将人脸框出，利用摄像头捕捉到的人脸特征与特征库的人脸特征比对进而进行预测，获得预测到的学号和预测指标。如果预测指标小于70则将对应学号在第几行输出，并且做好比对记录，获得该学号对应的学生名字。</p><p>如果比对成功了五次及以上，就在对应的result文件夹中的签到表中签到对应的名字，并输出签到成功，签到过程中使用time库记录签到的时间。在表格中名字后面用红色字体写出签到的名字，用黄色字体写出签到的时间，并且保存签到好的表格。</p><h2 id="2-4设计GUI界面"><a href="#2-4设计GUI界面" class="headerlink" title="2.4设计GUI界面"></a>2.4设计GUI界面</h2><p>本项目使用tkinter库设计GUI界面，tkinter是python自带的图形用户界面编辑库。</p><p>该界面只使用了比较基础的组件：标签和按键。设置按键的显示格式和对应的功能函数，为功能函数添加命名，连接到前面写好的程序中，实现界面所需的采集人脸图片、训练数据并创建人脸特征库、人脸比对并签到、查看签到表、查看项目说明文档、退出界面，一共七个功能。使用os.system函数即可将功能函数链接到.py文件，使用title函数和geometry函数设置窗口标题和位置，使用mainloop函数使整个签到系统运行起来，并实现循环，即不断点击按键实现响应功能，直到点击退出按键才会退出系统。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> GUI </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hough变换的车道线检测</title>
      <link href="/2021/05/12/My-Post9/"/>
      <url>/2021/05/12/My-Post9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h1><h2 id="1-1项目要求"><a href="#1-1项目要求" class="headerlink" title="1.1项目要求"></a>1.1项目要求</h2><p>本项目要求学习掌握关于Hough变换实现直线检测的原理知识，并基于Hough变换利用Simulink仿真器实现视频车道线的检测。</p><p>常见的车道线检测方法大致可以分为三类：<br>（1）传统方法；（2）传统图像处理与深度学习相结合的方法；（3）端到端的深度学习的方法。</p><p>传统的车道线检测方法基本分为几个模块：图像清理（障碍物遮挡检测，阴影消除，曝光矫正）；特征提取（车道线检测）；车道线模型拟合（横向/纵向）；时域整合（前后帧）；图像-物理空间（路面坐标系）的对应等。</p><h2 id="1-2项目内容及方案"><a href="#1-2项目内容及方案" class="headerlink" title="1.2项目内容及方案"></a>1.2项目内容及方案</h2><p>本项目采用基于Hough变换的直线检测方法来检测车道线，Hough变换是一种用于检测直线（也可检测圆形）的经典算法，可以结合Canny算法检测直线车道线。</p><p>其实现方法为经过Canny算法得到边缘分布图像后，构建一个Hough参数空间，利用点与线的对偶性，将图像空间的线条变为参数空间的聚集点，从而检测给定图像是否存在给定性质的曲线。这样就把原始图像中直线检测问题转变为寻找参数空间中的峰值问题。简单解释下，元空间的点都对应参数空间的线，原空间的直线都对应参数空间中曲线的交点。即可以通过参数空间曲线的交点个数来寻找原空间中的直线。</p><p>本项目仅使用较简单的操作实现视频车道线的基本检测，在视频中显示检测到的直线，处理过程共包括两个步骤：图像预处理和基于Hough变换的车道线检测。</p><h1 id="2-项目原理"><a href="#2-项目原理" class="headerlink" title="2 项目原理"></a>2 项目原理</h1><h2 id="2-1图像预处理"><a href="#2-1图像预处理" class="headerlink" title="2.1图像预处理"></a>2.1图像预处理</h2><p>输入为一段车辆在道路上行驶的视频，车前摄像头拍到的道路视频，来自于MATLAB中自带的视频片段。首先对输入图像中有车道线的部分进行截取，去掉不关注的部分，简化图像从而有利于对车道线的检测。将图像由RGB图像转换成灰度图像，然后对图像进行滤波操作，接着采用OTSU算法将图像转换成二值图像。</p><p>其中，OTSU算法是一种确定图像二值化分割阈值的算法，由日本学者大津于1979年提出。该方法又称作最大类间方差法，因为按照OTSU算法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大，在本项目中使图像中的车道线更加明显。它被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。</p><p>其原理是根据图像的灰度特性来划分图像中的背景和前景部分。因为方差是灰度分布均匀性的一种度量，背景和前景之间的类间方差越大，说明构成图像的两部分的差别越大，当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此，使类间方差最大的分割意味着错分概率最小。但它也有缺点，比如对图像噪声敏感，只能针对单一目标分割，当目标和背景大小比例悬殊、类间方差函数可能呈现双峰或者多峰时效果不是很好。</p><h2 id="2-2基于Hough变换的车道线识别"><a href="#2-2基于Hough变换的车道线识别" class="headerlink" title="2.2基于Hough变换的车道线识别"></a>2.2基于Hough变换的车道线识别</h2><p>将图像预处理部分得到的二值图像作为输入，对图像进行Hough变换检测其中的直线车道线。Simulink中的Hough Transform 模块实现标准 Hough 变换 （SHT），该模块共有三个变量，分别是Hough、Theta和Rho。变量 Rho 是沿垂直于线条的向量从原点到线条的距离，变量Theta 是 x 轴与此向量之间的角度，变量之间的关系式为：</p><p>Rho = x<em>cos(Theta) + y</em>sin(Theta)</p><p>该模块经过计算生成一个参数空间矩阵Hough，其行和列分别对应于这些 Rho 和 Theta 值。在计算 Hough 变换后，使用Find Local Maxima模块来求得参数空间中的峰值，基于Hough变换的原理，这些峰值表示的是输入图像中可能存在的线条。</p><p>在标识 Hough 变换中的峰值后，可以使用 Hough Lines 模块进行Hough 反变换从而得到 Hough 变换中对应于峰值的线段的端点，该模块会自动填充线段中的小间隙，从而检测并显示出图像中的直线，将图像复原为原图像大小，并和原视频叠加，设置检测出的直线的线条粗细和颜色等参数，进而得到最终的输出图像，其中黄色直线即为检测到的直线车道线。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
            <tag> 车道线检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于图像处理的车辆识别及智能信号灯控制系统</title>
      <link href="/2021/05/02/My-Post8/"/>
      <url>/2021/05/02/My-Post8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h1><h2 id="1-1项目要求"><a href="#1-1项目要求" class="headerlink" title="1.1项目要求"></a>1.1项目要求</h2><p>本项目要求使用Simulink仿真实现车辆识别计数和仿真交通信号灯系统，并且使用硬件搭信号灯控制系统的电路，将程序上传至Arduino控制器，实现硬件信号灯显示和数码管计数功能。</p><p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。包含硬件（各种型号的Arduino板）和软件（Arduino IDE)。其特点：</p><p>（1）跨平台：Arduino IDE可以在Windows、Macintosh OS X、Linux三大主流操作系统上运行，而其他的大多数控制器只能在Windows上开发。</p><p>（2）简单清晰：Arduino IDE基于processing IDE开发。对于初学者来说，极易掌握，同时有着足够的灵活性。 </p><p>（3）开放性：Arduino的硬件原理图、电路图、IDE软件及核心库文件都是开源的，在开源协议范围内里可以任意修改原始设计及相应代码。</p><p>（4）编程方式多样，代码简洁：Arduino编程主要有以下几种方式：第一种是使用官网Arduino IDE编程环境，这可以在官网下载，支持Windows，MacOS，Linux操作系统。第二如果不太喜欢写代码，或者是教小孩子玩Arduino，也有图形化的编程环境，比如Mixly/Scratch。</p><h2 id="1-2项目内容及方案"><a href="#1-2项目内容及方案" class="headerlink" title="1.2项目内容及方案"></a>1.2项目内容及方案</h2><p>这里将项目划分成三大块内容，分别是：</p><p>1、视频车辆的识别和计数。该模块使用Simulink仿真实现，共分为三个阶段，分别是背景提取、识别车辆和车辆计数，最终实现视频中车辆的识别用目标框标出，并且统计经过车辆的数目，以字幕的形式显示在画面中。</p><p>2、红绿灯设计。设计一个十字路口（东西、南北）的交通灯控制电路，放行时间由车流量决定。该模块要求实现以下4个状态：</p><p>S1：东西方向绿灯亮，南北方向红灯亮，时间T1； </p><p>S2：东西方向黄灯亮，南北方向红灯亮，时间5s； </p><p>S3：南北方向绿灯亮，东西方向红灯亮，时间T2； </p><p>S4：南北方向黄灯亮，东西方向红灯亮，时间5s。</p><p>红绿灯设计的相关设计要求如下：</p><p>（1）东西及南北方向的车辆交替放行，放行时间依据车流量设定；</p><p>（2）每次绿灯变红灯时，黄灯先亮5秒；</p><p>（3）具有倒计时功能。</p><p>3、人行横道信号灯设计。人行横道信号灯是专门为方便行人设计的一种交通信号灯。行人穿越马路，只需按一下灯杆上的绿色按钮，车辆信号灯变红，人行信号灯变绿，行人就可以安全通过。该模块的设计要求如下：</p><p>（1）车辆信号灯由红灯、绿灯、黄灯组成。红灯表示禁止通行，绿灯表示准许通行，黄灯表示警示。人行信号灯由红灯、绿灯组成，红灯表示禁止通行，绿灯表示准许通行，绿灯闪烁提醒行人快速通过；</p><p>（2）初始状态（S1）：车辆信号灯绿灯亮，人行信号灯红灯亮，车辆行驶；</p><p>（3）当行人按下按钮，车辆信号灯由绿灯→黄灯闪（3秒）→红灯，人行信号灯由红灯→绿灯（亮10秒）→绿灯（闪5秒），灯闪烁的时间间隔为0.5s；</p><p>（4）使用七段数码管进行倒计时；</p><p>（5）使用Simulink编写程序，使用Arduino控制板、面包板、LED灯等搭建电路。</p><h1 id="2-项目原理"><a href="#2-项目原理" class="headerlink" title="2 项目原理"></a>2 项目原理</h1><h2 id="2-1背景提取"><a href="#2-1背景提取" class="headerlink" title="2.1背景提取"></a>2.1背景提取</h2><p>输入车辆行驶路段视频，首先将原视频的RGB图像转换成灰度图像，方便后续处理，然后提取图像背景。背景提取是在视频图像序列中提取出静止不动的景物，因为摄像机是不动的，因此图像中的每个像素点都有一个对应的背景值，在一段时间内，这个背景值是比较固定的。背景提取的目标就是根据视频图像序列，找出图像中每一点的背景值。背景提取有很多算法，包括中值法、帧间差分法、高斯背景差分法、ViBe背景提取算法以及它的改进算法ViBe+，还有针对运动摄像机的光流法等。</p><p>本项目使用简单的中值法来提取图像背景，背景是静止不动的，像素值几乎保持不变。获取视频不同帧的若干张图片，将其对应点的像素大小相加，取中值即为背景像素值，于是就提取出了视频的背景。</p><h2 id="2-2识别车辆"><a href="#2-2识别车辆" class="headerlink" title="2.2识别车辆"></a>2.2识别车辆</h2><p>将原视频减去上一步骤中提取出的背景就可以得到车辆图像。但是，这会使黑色车辆无法显示，通过对图像加绝对值的方法实现黑色车辆也可以显示。然后将灰度图像转换成二值图像，使车辆显示更加清晰，可以非常清楚的识别出所有车辆。然后对车辆进行填充，再使用Blob Analysis模块调用opencv的功能函数包，实现车辆位置检测，给识别到的车辆添加目标框，设置目标框的线宽和颜色等参数，并且添加字幕显示当前画面中的车辆数目。</p><h2 id="2-3车辆计数"><a href="#2-3车辆计数" class="headerlink" title="2.3车辆计数"></a>2.3车辆计数</h2><p>车辆计数通过在图像中放置矩形框并检测是否有车辆经过矩形框的方式实现，首先绘制两个矩形框，将其放置在视频底部，使所有通过的车辆都能经过这两个矩形框，从而都能被检测到。</p><p>编写程序，用于判断矩形框中是否有车辆通过，如果有车辆通过则计数加1，不断累计。这里使用Chart模块实现不停的脉冲累计，当计数结果达到100就重新开始计数。将两个矩形框得到的车辆数目相加，即可得到最终的车辆总数。</p><h2 id="2-4红绿灯设计"><a href="#2-4红绿灯设计" class="headerlink" title="2.4红绿灯设计"></a>2.4红绿灯设计</h2><p>红绿灯设计模块使用MATLAB中的Chart模块来设计，首先设计四个状态，并给四个状态添加变量，其对应的状态表如下：</p><p>S1      0       0       1       1       0       0       T1</p><p>S2      0       1       0       1       0       0       5s</p><p>S3       1       0       0       0       0       1       T2</p><p>S4       1       0       0       0       1       0       5s</p><p>根据状态表设置好四个状态，定义好实验所需的计数变量EW_Count和SN_Count，根据设计要求和状态之间的转换条件，在Chart模块的状态之间放置转换条件，添加倒计时功能，其中放行时间T1和T2的设定条件依据下表设定。</p><p>条件                 →   执行</p><p>N &gt;30             →  T1=55; T2=35;</p><p>N&gt;10 &amp;&amp; N&lt;=30     →  T1=50; T2=40;</p><p>N&gt;-10 &amp;&amp; N&lt;=10     →  T1=45; T2=45;</p><p>N&gt;-30 &amp;&amp; N&lt;=-10  →  T1=40; T2=50;</p><p>N&lt;=-30             →  T1=35; T2=55;</p><p>给最终设计好的模块设置输出端口使其与Arduino控制板相连，连接好硬件电路、信号灯和数码管，安装好相关驱动并进行设置，运行程序，数码管开始执行倒计时，倒计时结束信号灯转换，实现了完整的信号灯控制系统。</p><h2 id="2-5人行横道信号灯"><a href="#2-5人行横道信号灯" class="headerlink" title="2.5人行横道信号灯"></a>2.5人行横道信号灯</h2><p>人行横道信号灯设计模块同样使用MATLAB中的Chart模块，首先设计四个状态并添加变量，其中S2和S4状态要实现闪烁，所以将其分成两个块。</p><p>根据状态表设置每个状态所需变量，根据状态之间的转换条件进行状态连接，使其实现上文设计要求中的状态转换，并实现倒计时功能。给最终设计好的模块设置输出端口使其与Arduino控制板相连，连接好硬件电路、信号灯和数码管，安装好相关驱动并进行设置，运行程序，数码管开始倒计时，倒计时结束状态转换，实现了一个完整的人行横道信号灯控制系统。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> MATLAB </tag>
            
            <tag> 车辆识别 </tag>
            
            <tag> 交通信号灯控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器视觉技术》学习记录</title>
      <link href="/2021/03/09/My-Post7/"/>
      <url>/2021/03/09/My-Post7/</url>
      
        <content type="html"><![CDATA[<p>这里只列出书籍学习后的总结框架，具体笔记知识点见笔记本中。</p><h1 id="第一、二章-机器视觉和图像处理"><a href="#第一、二章-机器视觉和图像处理" class="headerlink" title="第一、二章  机器视觉和图像处理"></a>第一、二章  机器视觉和图像处理</h1><p>1.机器视觉研究现状、现有技术和机器视觉的功能和精度等。</p><p>2.数字图像采集和量化。</p><p>3.彩色图像与灰度图像。</p><h1 id="第三章-目标提取"><a href="#第三章-目标提取" class="headerlink" title="第三章 目标提取"></a>第三章 目标提取</h1><p>1.基于阈值的目标提取。</p><p>2.基于颜色的目标提取（RGB转换成HSI）。</p><p>3.基于差分的目标提取：分帧间差分和背景差分。</p><h1 id="第四章-边缘检测"><a href="#第四章-边缘检测" class="headerlink" title="第四章 边缘检测"></a>第四章 边缘检测</h1><p>1.基于微分的边缘检测。</p><p>2.基于模板匹配的边缘检测。</p><p>3.边缘图像二值化处理和细线化处理。</p><p>4.用于边缘检测的Canny算法。</p><h1 id="第五章-图像平滑处理"><a href="#第五章-图像平滑处理" class="headerlink" title="第五章 图像平滑处理"></a>第五章 图像平滑处理</h1><p>1.常见图像噪声：椒盐噪声和随机噪声。</p><p>2.常见图像滤波方法：均值滤波，中值滤波，高斯滤波。</p><p>3.模糊图像清晰化处理方法：对比度增强，直方图均衡化，暗通道先验法。</p><p>4.二值图像的平滑处理：膨胀和腐蚀。</p><h1 id="第六章-几何参数检测"><a href="#第六章-几何参数检测" class="headerlink" title="第六章 几何参数检测"></a>第六章 几何参数检测</h1><p>1.图形的特征参数，区域标记。</p><p>2.基于特征参数提取物体。</p><p>3.基于特征参数消除噪声。</p><h1 id="第七章-Hough变换"><a href="#第七章-Hough变换" class="headerlink" title="第七章 Hough变换"></a>第七章 Hough变换</h1><p>1.Hough变换直线检测：传统的、过已知点的。</p><p>2.Hough变换曲线检测。</p><h1 id="第八章-几何变换"><a href="#第八章-几何变换" class="headerlink" title="第八章 几何变换"></a>第八章 几何变换</h1><p>1.图像的放大缩小、平移、旋转。</p><p>2.图像的复杂变形：组合放大缩小、平移、旋转。</p><p>3.几何坐标表示。</p><h1 id="第九章-傅里叶变换"><a href="#第九章-傅里叶变换" class="headerlink" title="第九章 傅里叶变换"></a>第九章 傅里叶变换</h1><p>1.连续信号傅里叶变换-&gt;离散信号傅里叶变换-&gt;图像的二维傅里叶变换。</p><p>2.图像的滤波处理。</p><h1 id="第十章-小波变换"><a href="#第十章-小波变换" class="headerlink" title="第十章 小波变换"></a>第十章 小波变换</h1><p>1.连续信号小波变换-&gt;离散信号小波变换-&gt;小波族。</p><p>2.信号的分解与重构。</p><p>3.二维离散小波变换-&gt;图像处理中的小波变换。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语义分割性能提升方案</title>
      <link href="/2021/01/27/My-Post6/"/>
      <url>/2021/01/27/My-Post6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-外部数据"><a href="#1-外部数据" class="headerlink" title="1 外部数据"></a>1 外部数据</h1><ul><li>LUng Node Analysis Grand Challenge数据：来自外科医生的详细注释；</li><li>LIDC-IDRI数据：上面有每个肿瘤的放射学家描述；</li><li>Flickr CC, Wikipedia Commons datasets；</li><li>Human Protein Atlas Dataset；</li><li>IDRiD dataset。</li></ul><p>数据的探索：</p><ul><li>用0.5阈值对三维分割进行聚类；</li><li>确认在测试标签的分配上是否有实质性的差异。</li></ul><h1 id="2-图像预处理和数据增强"><a href="#2-图像预处理和数据增强" class="headerlink" title="2 图像预处理和数据增强"></a>2 图像预处理和数据增强</h1><p><strong>图像预处理方法</strong>有：</p><ul><li>使用高斯差分方法进行斑点检测；</li><li>使用基于图像块的输入进行训练，以减少训练时间；</li><li>加载数据时，用 cudf 替换 Pandas；</li><li>确保所有图像保持相同的方向；</li><li>应用对比度受限的自适应直方图均衡化；</li><li>使用 OpenCV 对所有常规图像进行预处理；</li><li>采用自主学习并手动添加注释；</li><li>将所有图像调整成相同的分辨率，以便将相同的模型用于不同厚度的扫描；</li><li>将扫描图像转换为规范化的3D numpy数组；</li><li>对单张图像除雾使用暗通道先验法；</li><li>转换所有数据到亨斯菲尔德单元；</li><li>在RGBY上使用成对相关法查找重复图像；</li><li>开发取样器使标签更加平衡；</li><li>对测试数据应用伪标记以提高得分；</li><li>缩小图像/遮罩到320×480；</li><li>内核大小为32×32的直方图均衡化(CLAHE)；</li><li>转换DCM到PNG；</li><li>当有重复的图像时，计算每个图像的md5哈希值。</li></ul><p>数据增强能够使网络具有更复杂的表征能力，从而减小网络性能在验证集和训练集以及最终测试集上的差距，让网络更好地学习迁移数据集上的数据分布。<strong>数据增强方法</strong>有：</p><ul><li>用 albumentations 包进行数据增强；</li><li>使用 90 度随机旋转；</li><li>使用水平、垂直翻转或这两个方向都做翻转；</li><li>尝试进行复杂的几何变换，包括弹性变换、透视变换、分段仿射变换、枕形失真；</li><li>应用随机 HSV；</li><li>使用损失较小的增强数据进行泛化，以防止有用图像信息丢失；</li><li>应用通道 shuffle(洗牌)；</li><li>根据类别频率进行数据扩充；</li><li>应用高斯噪声；</li><li>使用无损排列的三维图像的数据增强；</li><li>从0到45度随机旋转；</li><li>以0.8到1.2之间的随机因子改变规模；</li><li>改变亮度；</li><li>随机改变色调，饱和度和值；</li><li>应用D4扩增；</li><li>对比度受限的自适应直方图均衡化；</li><li>使用自动扩充策略。</li></ul><h1 id="3-模型架构的改进"><a href="#3-模型架构的改进" class="headerlink" title="3 模型架构的改进"></a>3 模型架构的改进</h1><p>可用在图像分割上的<strong>网络框架</strong>有：</p><ul><li>使用基于 U-net 的架构，采用这些概念并将其应用于三维输入张量；</li><li>使用自动主动学习和添加手动注释；</li><li>用 inception-ResNet v2 架构得到具备不同感受野的训练特征；</li><li>经过对抗训练的 Siamese 网络；</li><li>以密集（FC）层作为最后一层的 ResNet50、Xception、Inception ResNet v2 x 5；</li><li>使用全局最大池化层，无论输入尺寸如何，该层都将返回固定长度的输出；</li><li>使用堆叠的膨胀卷积；</li><li>VoxelNet；</li><li>用 concat 和 conv1x1 替换 LinkNet 跳跃连接中的加号；</li><li>广义平均池化；</li><li>Keras NASNetLarge使用224x224x3从头开始训练模型；</li><li>用 3D 卷积网络在图像上滑动；</li><li>使用在 Imagenet 数据集上预训练的 ResNet152 作为特征提取器；</li><li>用dropout替换3个完全连接的层；</li><li>在解码器中使用ConvTranspose；</li><li>应用VGG基线架构；</li><li>实现接受域调整后的C3D网络和一个64单位的瓶颈层在网络的末端；</li><li>使用带有预先训练过的权值的UNet类型架构，以改善对8位RGB输入图像的二进制分割收敛性和性能；</li><li>使用LinkNet因为它速度快，内存效率高。</li></ul><p><strong>经典网络框架</strong>：</p><ul><li>MASKRCNN</li><li>BN-Inception</li><li>Fast Point R-CNN</li><li>Seresnext</li><li>UNet and Deeplabv3</li><li>Faster RCNN</li><li>SENet154</li><li>ResNet152</li><li>NASNet-A-Large</li><li>EfficientNetB4</li><li>ResNet101</li><li>GAPNet</li><li>PNASNet-5-Large</li><li>Densenet121</li><li>AC-GAN</li><li>XceptionNet (96), XceptionNet (299), Inception v3 (139),</li><li>InceptionResNet v2 (299), DenseNet121 (224)</li><li>AlbuNet (resnet34) from ternausnets</li><li>SpaceNet</li><li>Resnet50 from selim_sef SpaceNet 4</li><li>SCSEUnet (seresnext50) from selim_sef SpaceNet 4</li><li>自定义的Unet and Linknet architecture</li><li>FPNetResNet50 (5 folds)</li><li>FPNetResNet101 (5 folds)</li><li>FPNetResNet101 (7 folds with different seeds)</li><li>PANetDilatedResNet34 (4 folds)</li><li>PANetResNet50 (4 folds)</li><li>EMANetResNet101 (2 folds)</li><li>RetinaNet</li><li>Deformable R-FCN</li><li>Deformable Relation Networks</li></ul><h1 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4 损失函数"></a>4 损失函数</h1><p>损失函数常用来估计模型预测结果与真值之间的差距。选择<strong>合适的损失函数</strong>，对模型效果很重要。一系列损失函数和使用场景如下：</p><ul><li>dice 系数：能够很好地处理不平衡数据；</li><li>加权边界损失：减少预测分割与真值之间的距离；</li><li>MultiLabelSoftMarginLoss：基于最大熵优化多标签一对多损失的标准；</li><li>具备 logit 损失的平衡交叉熵（Balanced cross entropy，BCE）：以特定系数权衡正例和负例；</li><li>Lovasz：基于子模损失的凸Lovasz扩展，对神经网络中的平均交点-联合损失进行直接优化；</li><li>FocalLoss + Lovasz：把FocalLoss和Lovasz损失相加得到；</li><li>Arc margin loss：合并边缘，以最大限度地提高表面可分性；</li><li>Npairs loss：计算y_true和y_pred之间的Npairs损失</li><li>BCE and Dice损失函数的结合；</li><li>LSEP：两两排序在任何地方都是平滑的，因此更容易优化；</li><li>Center loss：同时学习每个类的深层特征中心，并惩罚深层特征与其对应的类中心之间的距离；</li><li>Ring Loss：增加标准损失功能，如Softmax；</li><li>Hard triplet loss：训练网络在同一时间内嵌入同一类的特征，最大限度地提高不同类的嵌入距离；</li><li>1 + BCE – Dice ：包括减去BCE和Dice损失，然后加上1；</li><li>Binary cross-entropy –  log(dice):二值交叉熵减去Dice损失的对数；</li><li>BCE, dice and focal的组合；</li><li>Lovasz Loss：对平均交点-联合损失进行直接优化；</li><li>BCE + DICE：通过计算平滑的Dice系数函数得到Dice损失；</li><li>Focal loss with Gamma 2:对标准交叉熵准则的改进；</li><li>BCE + DICE + Focal:三个损失函数的总和；</li><li>Active Contour Loss:整合区域和大小信息，并将这些信息整合到一个密集深度学习模型中；</li><li>1024 * BCE(results, masks) + BCE(cls, cls_target)；</li><li>Focal + kappa:Kappa是深度学习中对有序数据进行多类分类的损失函数,把它和Focal损失相加；</li><li>ArcFaceLoss:用于深度人脸识别的附加角边缘损失；</li><li>只在正样本下训练的Soft Dice:使用预测的概率的Soft Dice；</li><li>2.7 <em> BCE(pred_mask, gt_mask) + 0.9 </em> DICE(pred_mask, gt_mask) + 0.1 * BCE(pred_empty, gt_empty)：Kaggler使用的自定义损失；</li><li>nn.SmoothL1Loss()：创建如果绝对元素误差低于1，则使用平方项，否则使用L1项的标准；</li><li>在使用均方误差目标函数的情况下，它似乎比二值交叉熵目标函数更好。</li></ul><h1 id="5-训练技巧"><a href="#5-训练技巧" class="headerlink" title="5 训练技巧"></a>5 训练技巧</h1><ul><li>尝试不同的<strong>学习率</strong>；</li><li>尝试不同<strong>批大小</strong>；</li><li>使用带有动量项的SDG，并且手动设置<strong>学习率衰减</strong>；</li><li><strong>数据增强</strong>过多会降低准确率；</li><li>使用<strong>裁剪</strong>后的图像训练，并在完整的图像上做预测；</li><li>在<strong>学习速率调整</strong>上使用Keras中的ReduceLROnPlateau()方法；</li><li>没有增强的训练直到稳定，然后在某些时期应用<strong>软增强</strong>和<strong>硬增强</strong>；</li><li>冻结除了最后一层以外所有的网络层，并使用Stage1中的1000张图片进行模型<strong>微调</strong>；</li><li>开发一个能使标签更加均匀的<strong>采样器</strong>；</li><li>使用<strong>类别感知采样</strong>（class aware sampling）；</li><li>在调整最后一层时使用<strong>dropout</strong>和增强；</li><li><strong>伪标记</strong>提高分数；</li><li>用<strong>Adam优化</strong>算法减少稳定期的学习率伴随着2-4的耐心；</li><li>使用<strong>循环学习率</strong>和<strong>SGD</strong>；</li><li>如果验证损失在两个连续的时期没有改善，则将学习率降低两倍；</li><li>重复10批中最差的一批；</li><li>使用默认UNET进行训练；</li><li>重叠贴图，使每个<strong>边缘像素</strong>被覆盖两次；</li><li><strong>超参数</strong>调优:训练的学习率，非最大抑制和推理的分数阈值；</li><li>移除低置信度得分的差边界框；</li><li>训练不同的卷积神经网络，然后建立一个集成；</li><li>当<strong>F1分数</strong>下降时停止训练；</li><li>逐渐降低不同的学习率；</li><li>用<strong>5折交叉验证</strong>和30次重复验证方式训练ANNs；</li><li>使用<strong>Neptune</strong>追踪你的实验。</li></ul><h1 id="6-集成方法"><a href="#6-集成方法" class="headerlink" title="6 集成方法"></a>6 集成方法</h1><p>许多机器学习竞赛（包括 Kaggle）中最优秀的解决方案所采用的集成方法都建立在一个这样的假设上：将<strong>多个模型组合在一起</strong>通常可以产生更强大的模型。集成方法有：</p><ul><li>多数投票法</li><li>XGBoost：最大恶性肿瘤在3个缩放等级，z位置和奇怪组织的数量；</li><li>LightGBM：多类别模型，只针对原始数据特性；</li><li>CatBoost：2层模型；</li><li>梯度增强分类器：用7个特征训练；</li><li>课程学习：加快模特培训，在这种技术中，模型首先在简单的样本上训练，然后逐步转移到困难的样本上；</li><li>集成 ResNet50、InceptionV3 和 InceptionResNetV2 的方法；</li><li>目标检测的集成方法；</li><li>由Mask RCNN, YOLOv3和具有DenseNet-121分类网络的Faster RCNN架构n组成的集合，</li></ul><h1 id="7-模型评估和验证方法的改进"><a href="#7-模型评估和验证方法的改进" class="headerlink" title="7 模型评估和验证方法的改进"></a>7 模型评估和验证方法的改进</h1><ul><li>类别不统一的阶级划分；</li><li>在调整模型最后一层时使用交叉验证方法以有效避免过拟合；</li><li>用于分类的10倍CV集成；</li><li>5个用于检测的10倍CV集成进行组合；</li><li>Sklearn的分层K折函数</li><li>k折交叉验证;</li><li>对抗验证和权衡。</li></ul><h1 id="8-后处理"><a href="#8-后处理" class="headerlink" title="8 后处理"></a>8 后处理</h1><ul><li><strong>测试时增强</strong>（Test Time Augmentation，TTA）：向模型多次展示经过不同随机变换的图像，取预测平均值；</li><li><strong>均衡使用测试预测概率</strong>，而不是仅使用预测类；</li><li>将<strong>几何平均数</strong>应用于预测；</li><li>在推理过程中将图块重叠，使每个边缘像素至少覆盖 3 次，因为 UNET 在边缘区域范围的预测往往较差；</li><li><strong>非极大抑制</strong>和边界框收缩；</li><li><strong>分水岭</strong>后处理：在实例分割问题中分离对象。</li></ul><h1 id="9-硬件配置"><a href="#9-硬件配置" class="headerlink" title="9 硬件配置"></a>9 硬件配置</h1><ul><li>AWS GPU，例如p2.xlarge with a NVIDIA K80 GPU</li><li>Pascal Titan-X GPU</li><li>8 TITAN X GPUs</li><li>6 GPUs: 21080Ti + 41080</li><li>8×NVIDIA Tesla P40服务器, 256 GB RAM and 28 CPU cores</li><li>i7 5930k Intel内核, 2×1080, 64 GB of RAM, 2x512GB SSD, 3TB HDD</li><li>GCP 1x P100, 8x CPU, 15 GB RAM, SSD or 2x P100, 16x CPU, 30 GB RAM</li><li>NVIDIA Tesla P100 GPU with 16GB of RAM</li><li>i7 5930k, 2×1080Intel内核, 64 GB of RAM, 2x512GB SSD, 3TB HDD<br>980Ti GPU, 2600k CPU, and 14GB RAM</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>需注意某些技巧可能有一定的适用范围，具体能不能用还要视数据而定。</p><p>译自：<a href="https://neptune.ai/blog/image-segmentation-tips-and-tricks-from-kaggle-competitions?utm_source=reddit&amp;utm_medium=post&amp;utm_campaign=blog-image-segmentation-tips-and-tricks-from-kaggle-competitions" target="_blank" rel="noopener">https://neptune.ai/blog/image-segmentation-tips-and-tricks-from-kaggle-competitions?utm_source=reddit&amp;utm_medium=post&amp;utm_campaign=blog-image-segmentation-tips-and-tricks-from-kaggle-competitions</a></p><p>原文中有各技巧的跳转链接，如果你想深入了解，只需跟随链接，查看最好的图像分割模型是如何建立的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语义分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研一前半学期学习总结</title>
      <link href="/2020/12/31/My-Post5/"/>
      <url>/2020/12/31/My-Post5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Python"><a href="#1-Python" class="headerlink" title="1 Python"></a>1 Python</h1><ul><li>MOOC北京理工大学《Python语言程序设计》课程学完(包含11章内容7个库16个实例)，笔记记录在幕布；</li></ul><ul><li>读完了《Python编程从入门到实践》这本书(包含Python基础知识和3个项目实战)，笔记补充进上一条的幕布；</li></ul><ul><li>对Python常用的操作方法和函数做了整理，记录在幕布；</li></ul><ul><li>学习Python在图形用户界面的应用，用PyQt5库做了一个简易信号与系统教学实验界面，撰写了一篇关于该系统的教改论文(未完成)。</li></ul><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><ul><li>B站上北京大学《数据结构与算法分析(Python版)》课程看完，笔记记录在幕布；</li></ul><ul><li>Leetcode刷了一些数据结构题目，笔记记录在word中，题目类型划分记录在幕布。</li></ul><h1 id="3-离散数学"><a href="#3-离散数学" class="headerlink" title="3 离散数学"></a>3 离散数学</h1><ul><li>B站上北京大学《离散数学》课程看了集合论和图论，但是基本没懂，笔记在打印的PPT上；</li></ul><ul><li>读《离散数学及其应用》这本书，书中例题有看，但是每节练习题都没做，书没看完。</li></ul><h1 id="4-数学建模"><a href="#4-数学建模" class="headerlink" title="4 数学建模"></a>4 数学建模</h1><ul><li>B站上清华大学基础课程看了一些，笔记记录在幕布；</li></ul><ul><li>B站小石老师建模算法课程看完，笔记记录在幕布，代码在文件夹中；</li></ul><ul><li>B站Python在数学建模中的应用课程看了PPT，笔记记录在幕布，代码在PPT上；</li></ul><ul><li>看了几份历年真题和优秀论文，总结了题目框架和解题思路在幕布；</li></ul><ul><li>成功参赛2020年中国研究生数学建模竞赛，完成了B题(汽油辛烷值优化建模)解题和论文撰写。</li></ul><h1 id="5-机器学习"><a href="#5-机器学习" class="headerlink" title="5 机器学习"></a>5 机器学习</h1><ul><li>周志华《机器学习》西瓜书学习，整理了电子版学习框架在blog，具体笔记在书上。</li></ul><h1 id="6-深度学习"><a href="#6-深度学习" class="headerlink" title="6 深度学习"></a>6 深度学习</h1><ul><li>李沐《动手学深度学习》只看了关于卷积神经网络和计算机视觉方面的东西；</li></ul><ul><li>看了《神经网络和深度学习》这本书，了解神经网络相关知识。</li></ul><h1 id="7-图像处理"><a href="#7-图像处理" class="headerlink" title="7 图像处理"></a>7 图像处理</h1><ul><li>看《机器视觉技术》这本书，整理电子版学习框架在word，具体笔记在本子上；</li></ul><ul><li>学会用Python的PIL库进行图像处理，详情在blog；</li></ul><ul><li>学会使用Pytorch中的图像预处理包torchvision.transforms对训练样本进行图像增强。</li></ul><h1 id="8-计算机视觉"><a href="#8-计算机视觉" class="headerlink" title="8 计算机视觉"></a>8 计算机视觉</h1><h2 id="8-1-图像分类"><a href="#8-1-图像分类" class="headerlink" title="8.1 图像分类"></a>8.1 图像分类</h2><ul><li>学习了卷积，池化，激活函数，优化算法，损失函数，以及如何缓解过拟合，如何提高计算性能等；</li></ul><ul><li>学习8个卷积神经网络模型，读了其中5个网络的经典论文。8个卷积神经网络模型分别是：LeNet，AlexNet，VGG，NiN，GoogLeNet，ResNet，DenseNet，MobileNet；</li></ul><ul><li>学习了如何用Pytorch，Tensorflow，MXNet编写程序构建上述网络模型，学会了迁移学习和微调；</li></ul><ul><li>搜集了若干图像分类的数据集，总结在excel表格中；</li></ul><ul><li>学会了用Pytorch编写读取数据集的不同方法；</li></ul><ul><li>学习图像增强：调用DataLoader实例进行数据读取，提供tranform函数将图像增强应用到训练样本；</li></ul><ul><li>在不同数据集上跑AlexNet网络代码进行训练和测试；</li></ul><ul><li>学习使用多GPU训练模型-Pytorch；</li></ul><ul><li>总结图像分类性能提升方案在blog中。</li></ul><h2 id="8-2-目标检测"><a href="#8-2-目标检测" class="headerlink" title="8.2 目标检测"></a>8.2 目标检测</h2><ul><li>下载并了解了目标检测数据集PASCAL VOC的构成；</li></ul><ul><li>学习了10个目标检测算法，读了这10个算法的经典论文和一篇目标检测性能提升方案的论文Bag of Freebies。10个算法分别是:R-CNN, Fast R-CNN, Faster R-CNN, SSD, YOLOv1, YOLOv2, YOLOv3, YOLOv4, RetinaNet, Mask R-CNN。</li></ul><ul><li>学习如何用Pytorch编写程序实现Faster R-CNN、SSD、YOLOv3 SPP、YOLOv4等算法，下载并读了代码；</li></ul><ul><li>学习如何计算目标检测结果的mAP值，了解了COCO官方目标检测结果的评价指标。</li></ul><h2 id="8-3-语义分割"><a href="#8-3-语义分割" class="headerlink" title="8.3 语义分割"></a>8.3 语义分割</h2><ul><li>学习了很多语义分割网络，包括FCN、U-Net、UNet++、UNet3+、Attention U-Net、R2U-Net、SA-UNet、SegNet、PSPNet、DeepLab V1~V3+等。</li></ul><ul><li>读基础网络改进策略的相关论文，包括融合attention的改进，融合Transformer的改进，融合半监督GAN的改进，超像素分割优化等。（也有读到关于融合金字塔结构，融合图卷积，域自适应，弱监督、无监督的相关策略，但是没有深入了解）</li></ul><ul><li>全面了解了语义分割中的注意力机制，即如何进行像素点之间的相关性建模，读了相关论文，包括Non-local，PSANet，DANet，CCNet，DGMN，Local Relation Network等。以及了解了如何进行像素特征低秩重建，即像素到语义节点的映射与节点到像素的反映射（压缩与反压缩），读了相关论文，包括A2Net，SGR，Beyonds Grids，GloRe，LatentGNN，APCNet，EMANet等。</li></ul><ul><li>做了视网膜血管分割的实验，所用数据集为DRIVE，训练过的网络有：U-Net，U-Net++，R2U-Net，Attention U-Net和Attention R2U-Net，并且进行了性能评估。尝试利用语义分割性能改进策略进行实验，使用不同损失函数训练网络，并做了结果评估。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习进展阶段性总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python PIL库进行图像处理</title>
      <link href="/2020/12/02/My-Post4/"/>
      <url>/2020/12/02/My-Post4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-PIL介绍"><a href="#1-PIL介绍" class="headerlink" title="1 PIL介绍"></a>1 PIL介绍</h1><p>图像库PIL(Python Image Library)是Python的第三方图像处理库，但是由于其强大的功能与众多的使用人数，几乎已经被认为是<strong>python官方图像处理库</strong>了。PIL历史悠久，原来是只支持python2.x的版本的，后来出现了移植到python3的库pillow，pillow号称是friendly fork for PIL，其功能和PIL差不多，但是支持python3。本文主要介绍PIL那些最常用的特性与用法，具体函数和使用实例见<a href="https://pillow.readthedocs.io/en/stable/reference/Image.html" target="_blank" rel="noopener">https://pillow.readthedocs.io/en/stable/reference/Image.html</a></p><p>PIL可以做的事情：</p><ul><li><strong>图像归档(Image Archives)</strong>。PIL非常适合于图像归档以及图像的批处理任务。你可以使用PIL创建缩略图，转换图像格式，打印图像等等。</li></ul><ul><li><strong>图像展示(Image display)</strong>。PIL较新的版本支持包括Tk PhotoImage，BitmapImage还有windows DIB等接口。PIL支持众多的GUI框架接口，可以用于图像展示。</li></ul><ul><li><strong>图像处理(Image Processing)</strong>。PIL包括了基础的图像处理函数，包括对点的处理，使用众多的卷积核(convolution kernels)做过滤(filter),还有颜色空间的转换。PIL库同样支持图像的大小转换，图像旋转，以及任意的仿射变换。PIL还有一些直方图的方法，允许你展示图像的一些统计特性。这个可以用来实现图像的自动对比度增强，还有全局的统计分析等。</li></ul><h1 id="2-PIL中的Image类及其常用方法"><a href="#2-PIL中的Image类及其常用方法" class="headerlink" title="2 PIL中的Image类及其常用方法"></a>2 PIL中的Image类及其常用方法</h1><p><strong>Image类是PIL中的核心类</strong>，你有很多种方式来对它进行初始化，比如从文件中加载一张图像，处理其他形式的图像，或者是从头创造一张图像等。Image模块操作的<strong>基本属性和方法</strong>都包含于此模块内。如size、model、format等属性；open、save、conver、show等方法。下面是PIL的 Image类中常用的属性和方法:</p><h2 id="2-1-基本属性"><a href="#2-1-基本属性" class="headerlink" title="2.1 基本属性"></a>2.1 基本属性</h2><h3 id="2-1-1-format属性"><a href="#2-1-1-format属性" class="headerlink" title="2.1.1 format属性"></a>2.1.1 format属性</h3><pre><code>im.format ⇒ string or None</code></pre><p>这个属性标识了<strong>图像来源</strong>，如果图像不是从文件读取它的值就是None。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.format) #打印出格式信息im.show()</code></pre><h3 id="2-1-2-mode属性"><a href="#2-1-2-mode属性" class="headerlink" title="2.1.2 mode属性"></a>2.1.2 mode属性</h3><pre><code>im.mode ⇒ string</code></pre><p><strong>图像的模式</strong>，常见的mode 有 “L” (luminance) 表示灰度图像，“RGB”表示真彩色图像，和 “CMYK” 表示出版图像，表明图像所使用像素格式。如下为常见的mode描述：</p><p>“1”表示1位像素，黑白图像，存成8位像素</p><p>“L”表示8位像素，黑白图像</p><p>“P”表示9位像素，使用调色板映射到任何其他模式</p><p>“RGB”表示3*8位像素，彩色图像</p><p>“RGBA”表示4*8位像素，彩色图像+透明通道</p><p>“CMYK”表示4*8位像素，印刷四色模式或彩色印刷模式</p><p>“YCbCr”表示3*8位像素，色彩视频格式</p><p>“I”表示32位整型像素</p><p>“F”表示33位浮点型像素</p><p>代码实例如下：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.mode) #打印模式属性im.show()</code></pre><h3 id="2-1-3-size属性"><a href="#2-1-3-size属性" class="headerlink" title="2.1.3 size属性"></a>2.1.3 size属性</h3><pre><code>im.size ⇒ (width, height)</code></pre><p><strong>图像的尺寸</strong>，按照像素数计算，它的返回值为宽度和高度的二元组（width, height）。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.size) ## 打印图像尺寸im.show()</code></pre><p>命令行输出图片的尺寸为426×306。</p><h3 id="2-1-4-palette属性"><a href="#2-1-4-palette属性" class="headerlink" title="2.1.4 palette属性"></a>2.1.4 palette属性</h3><pre><code>im.palette ⇒ palette or None</code></pre><p><strong>颜色调色板表格</strong>。如果图像的模式是“P”，则返回Image  Palette类的实例；否则，将为None。</p><p>如下为对非“P”模式下的图像进行palette信息显示：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.palette)</code></pre><p>返回值为none，对图像进行convert操作，转换成“P”模式：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)new_im = im.convert(&#39;P&#39;)print(new_im.mode)print(new_im.palette)</code></pre><p>返回值为ImagePalette类的实例。</p><h3 id="2-1-5-info属性"><a href="#2-1-5-info属性" class="headerlink" title="2.1.5 info属性"></a>2.1.5 info属性</h3><pre><code>im.info ⇒ dictionary</code></pre><p><strong>存储图像相关数据的字典</strong>。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.info)</code></pre><h2 id="2-2-基本方法"><a href="#2-2-基本方法" class="headerlink" title="2.2 基本方法"></a>2.2 基本方法</h2><h3 id="2-2-1-open方法"><a href="#2-2-1-open方法" class="headerlink" title="2.2.1 open方法"></a>2.2.1 open方法</h3><pre><code>Image.open(file) ⇒ image Image.open(file, mode) ⇒ image</code></pre><p>要从文件<strong>加载图像</strong>，使用open()函数， 在Image模块代码如下:</p><pre><code>from PIL import Image           #调用库，包含图像类im = Image.open(&quot;3d.jpg&quot;)       #文件存在的路径，如果没有路径就是当前目录下文件im.show()</code></pre><p>需要知道的是在win的环境下im.show的方式为win自带的图像显示应用，打开并确认给定的图像文件。</p><p>该函数只会读文件头，而真实的图像数据直到试图处理该数据时才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。</p><h3 id="2-2-2-save方法"><a href="#2-2-2-save方法" class="headerlink" title="2.2.2 save方法"></a>2.2.2 save方法</h3><pre><code>im.save(outfile,options…)im.save(outfile, format, options…)</code></pre><p>用Image类的save()方法<strong>保存文件</strong>，使用给定的文件名保存图像。如果变量format缺省，则从文件名称的扩展名判断文件的格式，该方法返回为空。关键字options为文件编写器提供一些额外的指令。如果编写器不能识别某个选项，它将忽略它。用户可以使用文件对象代替文件名称。在这种情况下，用户必须指定文件格式。文件对象必须实现seek()、tell()和write()方法，且其以二进制模式打开。</p><p>如果方法save()因为某些原因失败，这个方法将产生一个异常（通常为IOERROR异常）。如果发生了异常，该方法也有可能已经创建了文件，并向文件写入了一些数据。如果需要的话，用户的应用程序可以删除这个不完整的文件。</p><h3 id="2-2-3-jpg转换成png方法"><a href="#2-2-3-jpg转换成png方法" class="headerlink" title="2.2.3 jpg转换成png方法"></a>2.2.3 jpg转换成png方法</h3><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im)im.save(&quot;3d.png&quot;)  #将&quot;3d.jpg&quot;保存为3d.png&quot;im = Image.open(&quot;3d.png&quot;)  #打开新的png图片print(im.format, im.size, im.mode)</code></pre><h3 id="2-2-4-convert方法"><a href="#2-2-4-convert方法" class="headerlink" title="2.2.4 convert方法"></a>2.2.4 convert方法</h3><p>①<code>im.convert(mode)⇒ image</code></p><p>将当前图像<strong>转换为其他模式</strong>，并且返回新的图像。当从一个调色板图像转换时，这个方法通过这个调色板来转换像素。如果不对变量mode赋值，该方法将会选择一种模式，在没有调色板的情况下，使得图像和调色板中的所有信息都可以被表示出来。</p><p>当从一个颜色图像转换为黑白图像时，PIL库使用ITU-R601-2 luma转换公式：<code>L = R * 299/1000 + G * 587/1000 + B * 114/1000</code></p><p>当转换为2位图像（模式“1”）时，源图像首先被转换为黑白图像。结果数据中大于127的值被设置为白色，其他的设置为黑色；这样图像会出现抖动。如果要使用其他阈值，更改阈值127，可以使用方法point()。为了去掉图像抖动现象，可以使用dither选项。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)new_im = im.convert(&#39;P&#39;)print(new_im.mode)new_im.show()</code></pre><p>②P模式：<code>im.convert(“P”,**options) ⇒ image</code></p><p>这个与第一个方法定义一样，但是当“RGB”图像转换为8位调色板图像时能更好的处理。可供选择的选项为：</p><p><strong>Dither=</strong>. 控制颜色抖动。默认是FLOYDSTEINBERG，与邻近的像素一起承担错误。不使能该功能，则赋值为NONE。</p><p><strong>palette=</strong>. 控制调色板的产生。默认是WEB，这是标准的216色的“web<br>palette”。要使用优化的调色板，则赋值为adaptive。</p><p><strong>colors=</strong>. 当选项palette为ADAPTIVE时，控制用于调色板的颜色数目。默认是最大值，即256种颜色</p><p>③<code>im.convert(mode,matrix) ⇒ image</code></p><p>使用<strong>转换矩阵</strong>将一个“RGB”图像转换为“L”或者“RGB”图像，变量matrix为4或者16元组。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.mode)rgb2xyz = (0.412453,0.357580, 0.180423, 0,  0.212671,0.715160, 0.072169, 0,  0.019334,0.119193, 0.950227, 0 )new_im = im.convert(&quot;L&quot;, rgb2xyz)print(new_im.mode)new_im.show()</code></pre><h3 id="2-2-5-new方法"><a href="#2-2-5-new方法" class="headerlink" title="2.2.5 new方法"></a>2.2.5 new方法</h3><pre><code>Image.new(mode,size) ⇒ imageImage.new(mode, size,color) ⇒ image</code></pre><p>使用给定的变量mode和size<strong>生成新的图像</strong>。size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。</p><p>在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0，这对向该图像复制或绘制某些内容是有用的。</p><p>下面将图像设置为128x128大小的红色图像：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)n_im= Image.new(&quot;RGB&quot;, (128, 128), &quot;#FF0000&quot;)n_im.show()</code></pre><p>生成的图像为128x128大小的黑色图像，因为变量color不赋值的话，图像内容被设置为0，即黑色：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)n_im= Image.new(&quot;RGB&quot;, (128, 128))n_im.show()</code></pre><p>生成的图像为128x128大小的绿色图像：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)n_im= Image.new(&quot;RGB&quot;, (128, 128),&quot;green&quot;)n_im.show()</code></pre><h3 id="2-2-6-copy方法"><a href="#2-2-6-copy方法" class="headerlink" title="2.2.6 copy方法"></a>2.2.6 copy方法</h3><pre><code>im.copy() ⇒ image</code></pre><p><strong>拷贝这个图像</strong>。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)im_copy = im.copy()</code></pre><p>图像im_copy和im完全一样。</p><h3 id="2-2-7-crop方法"><a href="#2-2-7-crop方法" class="headerlink" title="2.2.7 crop方法"></a>2.2.7 crop方法</h3><pre><code>im.crop(box) ⇒ image</code></pre><p>从当前的图像中返回一个<strong>矩形区域</strong>的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。用来表示在原始图像中截取的位置坐标，如box(100,100,200,200)就表示在原始图像中以左上角为坐标原点，截取一个100*100（像素为单位）的图像，对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)box = (20, 30, 300, 200)  #确定拷贝区域大小region = im.crop(box)  #将im表示的图片对象拷贝到region中，大小为boxregion.show()</code></pre><h3 id="2-2-8-paste方法"><a href="#2-2-8-paste方法" class="headerlink" title="2.2.8 paste方法"></a>2.2.8 paste方法</h3><pre><code>im.paste(image,box)</code></pre><p>将一张图<strong>粘贴</strong>到另一张图像上。变量box或者是一个给定左上角的2元组，或者是定义了左，上，右和下像素坐标的4元组，或者为空（与（0，0）一样）。如果给定4元组，被粘贴的图像的尺寸必须与区域尺寸一样。如果模式不匹配，被粘贴的图像将被转换为当前图像的模式。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)box=[0,0,100,100]im_crop = im.crop(box)print(im_crop.size,im_crop.mode)im.paste(im_crop, (100,100)) #(100,100,0,0)im.paste(im_crop, (400,400,500,500))im.show()</code></pre><h3 id="2-2-9-filter方法"><a href="#2-2-9-filter方法" class="headerlink" title="2.2.9 filter方法"></a>2.2.9 filter方法</h3><pre><code>im.filter(filter) ⇒ image</code></pre><p>返回一个使用给定<strong>滤波器处理</strong>过的图像的拷贝。具体参考图像滤波在ImageFilter 模块的应用，在该模块中，预先定义了很多增强滤波器，可以通过filter( )函数使用，预定义滤波器包括：BLUR、CONTOUR、DETaiL、EDGE_ENHANCE、EDGE_ENHANCE_MORE、EMBOSS、FIND_EDGES、SMOOTH、SMOOTH_MORE、SHARPEN。其中BLUR就是均值滤波，CONTOUR找轮廓，FIND_EDGES边缘检测，使用该模块时，需先导入。</p><pre><code>from PIL import Imagefrom PIL import ImageFilter #调取ImageFilterimgF = Image.open(&quot;3d.jpg&quot;)bluF = imgF.filter(ImageFilter.BLUR)#均值滤波conF = imgF.filter(ImageFilter.CONTOUR) #找轮廓edgeF = imgF.filter(ImageFilter.FIND_EDGES) #边缘检测imgF.show()bluF.show()conF.show()edgeF.show()</code></pre><h3 id="2-2-10-blend方法"><a href="#2-2-10-blend方法" class="headerlink" title="2.2.10 blend方法"></a>2.2.10 blend方法</h3><pre><code>Image.blend(image1,image2, alpha) ⇒ image</code></pre><p>使用给定的两张图像及透明度变量alpha，<strong>插值出一张新的图像</strong>。这两张图像必须有一样的尺寸和模式。</p><p>合成公式为：<code>out = image1 (1.0 - alpha) + image2  alpha</code></p><p>若变量alpha为0.0，返回第一张图像的拷贝。若变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值无限制。</p><pre><code>from PIL import Imageim1 = Image.open(&quot;3d.jpg&quot;)im2 = Image.open(&quot;3dd.jpg&quot;)print(im1.mode,im1.size)print(im2.mode,im2.size)im = Image.blend(im1, im2, 0.40)im.show()</code></pre><p>需保证两张图像的模式和大小是一致的。im1按照40%的透明度，im2按照60%的透明度，合成为一张。</p><h3 id="2-2-11-split方法"><a href="#2-2-11-split方法" class="headerlink" title="2.2.11 split方法"></a>2.2.11 split方法</h3><pre><code>im.split() ⇒ sequence</code></pre><p>返回当前图像<strong>各个通道组成的一个元组</strong>。例如，分离一个“RGB”图像将产生三个新的图像，分别对应原始图像的每个通道（红，绿，蓝）。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)r,g,b = im.split()print(r.mode)print(r.size)print(im.size)</code></pre><h3 id="2-2-12-composite方法"><a href="#2-2-12-composite方法" class="headerlink" title="2.2.12 composite方法"></a>2.2.12 composite方法</h3><pre><code>Image.composite(image1,image2, mask) ⇒ image</code></pre><p><strong>复合类</strong>使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。</p><pre><code>from PIL import Imageim1 = Image.open(&quot;3d.jpg&quot;)im2 = Image.open(&quot;3dd.jpg&quot;)r,g,b = im1.split() #分离出r，g，bprint(b.mode)print(im1.mode,im1.size)print(im2.mode,im2.size)im = Image.composite(im1,im2,b)im.show()</code></pre><p>b.mode为”L”，两图尺寸一致。</p><h3 id="2-2-13-eval方法"><a href="#2-2-13-eval方法" class="headerlink" title="2.2.13 eval方法"></a>2.2.13 eval方法</h3><pre><code>Image.eval(image,function) ⇒ image</code></pre><p>使用变量function对应的函数（该函数应该有一个参数）<strong>处理变量image所代表图像中的每一个像素点</strong>。如果变量image所代表图像有多个通道，那变量function对应的函数作用于每一个通道。注意：变量function对每个像素只处理一次，所以不能使用随机组件和其他生成器。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)def fun1(x):   return x*0.3def fun2(y):   return y*2.0im1_eval = Image.eval(im, fun1)im2_eval = Image.eval(im, fun2)im1_eval.show()im2_eval.show()</code></pre><h3 id="2-2-14-merge方法"><a href="#2-2-14-merge方法" class="headerlink" title="2.2.14 merge方法"></a>2.2.14 merge方法</h3><pre><code>Image.merge(mode,bands) ⇒ image</code></pre><p><strong>合并类</strong>使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。<br>变量mode与变量bands的关系：<code>len(ImageMode.getmode(mode).bands)= len(bands)</code></p><pre><code>from PIL import Imageim1 = Image.open(&quot;3d.jpg&quot;)im2 = Image.open(&quot;3dd.jpg&quot;)r1,g1,b1 = im1.split()r2,g2,b2 = im2.split()print(r1.mode,r1.size,g1.mode,g1.size)print(r2.mode,r2.size,g2.mode,g2.size)new_im=[r1,g2,b2]print(len(new_im))im_merge = Image.merge(&quot;RGB&quot;,new_im)im_merge.show()</code></pre><h3 id="2-2-15-draft方法"><a href="#2-2-15-draft方法" class="headerlink" title="2.2.15 draft方法"></a>2.2.15 draft方法</h3><pre><code>im.draft(mode,size)</code></pre><p>代码示例如下：</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.size,im.mode)new_im = im.draft(&quot;L&quot;, (200,200))print(new_im.size,new_im.mode)new_im.show()</code></pre><p>关键信息显示。</p><h3 id="2-2-16-getbands方法"><a href="#2-2-16-getbands方法" class="headerlink" title="2.2.16 getbands方法"></a>2.2.16 getbands方法</h3><pre><code>im.getbands()⇒ tuple of strings</code></pre><p>返回包括<strong>每个通道名称的元组</strong>。例如，对于RGB图像将返回（“R”,“G”,“B”）。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.getbands())</code></pre><h3 id="2-2-17-getbbox方法"><a href="#2-2-17-getbbox方法" class="headerlink" title="2.2.17 getbbox方法"></a>2.2.17 getbbox方法</h3><pre><code>im.getbbox() ⇒ 4-tuple or None</code></pre><p>计算<strong>图像非零区域的包围盒</strong>。这个包围盒是一个4元组，定义了左、上、右和下像素坐标。如果图像是空的，这个方法将返回空。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.getbbox())</code></pre><h3 id="2-2-18-getdata方法"><a href="#2-2-18-getdata方法" class="headerlink" title="2.2.18 getdata方法"></a>2.2.18 getdata方法</h3><pre><code>im.getdata() ⇒ sequence</code></pre><p>以包含像素值的sequence对象形式返回<strong>图像的内容</strong>。这个sequence对象是扁平的，以便第一行的值直接跟在第零行的值后面，等等。这个方法返回的sequence对象是PIL内部数据类型，它只支持某些sequence操作，包括迭代和基础sequence访问。使用<code>list(im.getdata())</code>，将它转换为普通的sequence。Sequence对象的每一个元素对应一个像素点的R、G和B三个值。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)sequ = im.getdata()sequ0 = list(sequ)print(sequ0[0])print(sequ0[1])print(sequ0[2])</code></pre><h3 id="2-2-19-getextrema方法"><a href="#2-2-19-getextrema方法" class="headerlink" title="2.2.19 getextrema方法"></a>2.2.19 getextrema方法</h3><pre><code>im.getextrema() ⇒ 2-tuple</code></pre><p>返回一个2元组，包括该图像中的<strong>最小和最大值</strong></p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.getextrema())</code></pre><p>该方法返回了R/G/B三个通道的最小和最大值的2元组。</p><h3 id="2-2-20-getpixel方法"><a href="#2-2-20-getpixel方法" class="headerlink" title="2.2.20 getpixel方法"></a>2.2.20 getpixel方法</h3><pre><code>im.getpixel(xy) ⇒ value or tuple</code></pre><p>返回<strong>给定位置的像素值</strong>。如果图像为多通道，则返回一个元组。该方法执行比较慢；如果用户需要使用python处理图像中较大部分数据，可以使用像素访问对象（见load），或者方法getdata()。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.getpixel((0,0)))print(im.getpixel((4,0)))r,g,b = im.split()print(b.getpixel((11,8)))  </code></pre><h3 id="2-2-21-histogram方法"><a href="#2-2-21-histogram方法" class="headerlink" title="2.2.21 histogram方法"></a>2.2.21 histogram方法</h3><p>①<code>im.histogram()⇒ list</code></p><p>返回一个<strong>图像的直方图</strong>。这个直方图是关于像素数量的list，图像中的每个象素值对应一个成员。如果图像有多个通道，所有通道的直方图会连接起来（例如，“RGB”图像的直方图有768个值)。二值图像（模式为“1”）当作灰度图像（模式为“L”）处理。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)imhis = im.histogram()print(len(imhis))print(imhis[0])print(imhis[150])print(imhis[300])</code></pre><p>②<code>im.histogram(mask)⇒ list</code></p><p>返回图像中模板图像<strong>非零地方的直方图</strong>。模板图像与处理图像的尺寸必须相同，并且要么是二值图像（模式为“1”），要么为灰度图像（模式为“L”）。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)r,g,b = im.split()imhis = im.histogram()print(r.mode)print(len(imhis))print(imhis[0])print(imhis[150])print(imhis[300])</code></pre><h3 id="2-2-22-load方法"><a href="#2-2-22-load方法" class="headerlink" title="2.2.22 load方法"></a>2.2.22 load方法</h3><pre><code>im.load()</code></pre><p>为图像<strong>分配内存并从文件中加载它</strong>（或者从源图像，对于懒操作）。正常情况下，用户不需要调用这个方法，因为在第一次访问图像时，Image类会自动地加载打开的图像。目前的版本，方法load()返回一个用于读取和修改像素的像素访问对象。这个访问对象像一个二维队列，如：</p><pre><code>pix = im.load()print(pix[x, y])</code></pre><p>其中<code>pix[x, y] =value</code>，通过这个对象访问比方法getpixel()和putpixel()快很多。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)pix = im.load()print(pix[0,2])</code></pre><h3 id="2-2-23-paste方法"><a href="#2-2-23-paste方法" class="headerlink" title="2.2.23 paste方法"></a>2.2.23 paste方法</h3><p>①<code>im.paste(colour,box)</code></p><p>使用<strong>同一种颜色填充变量box对应的区域</strong>。对于单通道图像，变量colour为单个颜色值；对于多通道，则为一个元组。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)im.paste((256,256,0),(0,0,100,100))#(256,256,0)表示黄色im.show()from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)im.paste(&quot;blue&quot;,(0,0,100,100))#或者“blue”im.show()</code></pre><p>②<code>im.paste(image,box, mask)</code></p><p>使用变量<strong>mask对应的模板图像来填充所对应的区域</strong>。可以使用模式为“1”、“L”或者“RGBA”的图像作为模板图像。模板图像的尺寸必须与变量image对应的图像尺寸一致。如果变量mask对应图像的值为255，则模板图像的值直接被拷贝过来；如果变量mask对应图像的值为0，则保持当前图像的原始值。变量mask对应图像的其他值，将对两张图像的值进行透明融合,如果变量image对应的为“RGBA”图像，即粘贴的图像模式为“RGBA”，则alpha通道被忽略。用户可以使用同样的图像作为原图像和模板图像。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)box=[300,300,400,400]im_crop =im.crop(box)r,g,b =im_crop.split()im.paste(im_crop, (200,200,300,300), r)im.show()</code></pre><h3 id="2-2-24-putdata方法"><a href="#2-2-24-putdata方法" class="headerlink" title="2.2.24 putdata方法"></a>2.2.24 putdata方法</h3><pre><code>im.putdata(data)im.putdata(data, scale, offset)</code></pre><p>从sequence对象中<strong>拷贝数据</strong>到当前图像，从图像的左上角（0，0）位置开始。变量scale和offset用来调整sequence中的值：<code>pixel = value*scale + offset</code></p><p>如果变量scale忽略，则默认为1.0。如果变量offset忽略，则默认为0.0。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)r, g, b = im.split()print(r.getpixel((0, 0)),r.getpixel((1, 0)),r.getpixel((2, 0)),r.getpixel((3, 0)),r.putdata([1, 2, 3, 4]),r.getpixel((0, 0)),r.getpixel((1, 0)),r.getpixel((2, 0)),r.getpixel((3, 0)),</code></pre><h3 id="2-2-25-resize方法"><a href="#2-2-25-resize方法" class="headerlink" title="2.2.25 resize方法"></a>2.2.25 resize方法</h3><pre><code>im.resize(size) ⇒ imageim.resize(size, filter) ⇒ image</code></pre><p>返回<strong>改变尺寸的图像的拷贝</strong>。变量size是所要求的尺寸，是一个二元组：（width, height）。变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。在当前的版本中bilinear和bicubic滤波器不能很好地适应大比例的下采样（例如生成缩略图）。用户需要使用ANTIALIAS，除非速度比质量更重要。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)region = im.resize((400, 400)) #重新设定大小region.show()</code></pre><h3 id="2-2-26-rotate方法"><a href="#2-2-26-rotate方法" class="headerlink" title="2.2.26 rotate方法"></a>2.2.26 rotate方法</h3><pre><code>im.rotate(angle) ⇒ imageim.rotate(angle,filter=NEAREST, expand=0) ⇒ image</code></pre><p>返回一个<strong>按照给定角度顺时钟围绕图像中心旋转后的图像拷贝</strong>。变量filter是NEAREST、BILINEAR或者BICUBIC之一。如果省略该变量，或者图像模式为“1”或者“P”，则默认为NEAREST。变量expand，如果为true，表示输出图像足够大，可以装载旋转后的图像。如果为false或者缺省，则输出图像与输入图像尺寸一样大。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)im_45 = im.rotate(45)im_30 = im.rotate(30, Image.NEAREST,1)print(im_45.size,im_30.size)im_45.show()im_30.show()</code></pre><h3 id="2-2-27-seek方法"><a href="#2-2-27-seek方法" class="headerlink" title="2.2.27 seek方法"></a>2.2.27 seek方法</h3><pre><code>im.seek(frame)</code></pre><p>在给定的文件序列中<strong>查找指定的帧</strong>。如果查找超越了序列的末尾，则产生一个EOFError异常。当文件序列被打开时，PIL库自动指定到第0帧上。</p><pre><code>from PIL import Imageim_gif = Image.open(&quot;miaomiao.gif&quot;)print(im_gif.mode)im_gif.show()#第0帧im_gif.seek(1)im_gif.show()im_gif.seek(3)im_gif.show()</code></pre><h3 id="2-2-28-tell方法"><a href="#2-2-28-tell方法" class="headerlink" title="2.2.28 tell方法"></a>2.2.28 tell方法</h3><pre><code>im.tell() ⇒ integer</code></pre><p>返回<strong>当前帧所处位置</strong>，从0开始计算。</p><pre><code>from PIL import Imageim_gif = Image.open(&quot;3d.gif&quot;)print(im_gif.tell())im_gif.seek(8)print(im_gif.tell())</code></pre><h3 id="2-2-29-thumbnail方法"><a href="#2-2-29-thumbnail方法" class="headerlink" title="2.2.29 thumbnail方法"></a>2.2.29 thumbnail方法</h3><pre><code>im.thumbnail(size)im.thumbnail(size, filter)</code></pre><p>修改当前图像，使其<strong>包含</strong>一个自身的<strong>缩略图</strong>，该缩略图尺寸不大于给定的尺寸。该方法计算一个合适的缩略图尺寸，使其符合当前图像的宽高比，调用方法draft()配置文件读取器，最后改变图像的尺寸。变量filter应该是NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果省略该变量，则默认为NEAREST。</p><p>注意：在当前PIL的版本中，滤波器bilinear和bicubic不能很好地适应缩略图产生。用户应该使用ANTIALIAS，图像质量最好。如果处理速度比图像质量更重要，可以选用其他滤波器。这个方法在原图上进行修改。如果用户不想修改原图，可以使用方法copy()拷贝一个图像。这个方法返回空。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)im.thumbnail((100,100))</code></pre><h3 id="2-2-30-transform方法"><a href="#2-2-30-transform方法" class="headerlink" title="2.2.30 transform方法"></a>2.2.30 transform方法</h3><p>①    </p><pre><code>im.transform(size,method, data) ⇒ imageim.transform(size, method, data, filter) ⇒ image</code></pre><p>用<strong>给定的尺寸生成一张新的图像</strong>，与原图有相同的模式，使用给定的转换方式将原图数据拷贝到新的图像中。</p><p>在当前的PIL版本中，参数method为EXTENT（裁剪出一个矩形区域），AFFINE（仿射变换），QUAD（将正方形转换为矩形），MESH（一个操作映射多个正方形）或者PERSPECTIVE。</p><p>变量filter定义了对原始图像中像素的滤波器。在当前的版本中，变量filter为NEAREST、BILINEAR、BICUBIC或者ANTIALIAS之一。如果忽略，或者图像模式为“1”或者“P”，该变量设置为NEAREST。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.size)imtra = im.transform((200, 200), Image.EXTENT, (0, 0, 300, 300))print(imtra.size)imtra.show()</code></pre><p>②</p><pre><code>im.transform(size,EXTENT, data) ⇒ imageim.transform(size, EXTENT, data, filter) ⇒ image</code></pre><p>从图像中<strong>裁剪一个区域</strong>。变量data为指定输入图像中两个坐标点的4元组(x0,y0,x1,y1)。输出图像为这两个坐标点之间像素的采样结果。例如，如果输入图像的(x0,y0)为输出图像的(0，0)点，(x1,y1)则与变量size一样。</p><p>这个方法可以用于在当前图像中裁剪，放大，缩小或者镜像一个任意的长方形。它比方法crop()稍慢，但是与resize操作一样快。</p><p>③</p><pre><code>im.transform(size, AFFINE, data) ⇒ imageim.transform(size, AFFINE,data, filter) ⇒ image</code></pre><p>对当前的图像进行<strong>仿射变换</strong>，变换结果体现在给定尺寸的新图像中。变量data是一个6元组(a,b,c,d,e,f)，包含一个仿射变换矩阵的第一个两行。输出图像中的每一个像素（x，y），新值由输入图像的位置（ax+by+c, dx+ey+f）的像素产生，使用最接近的像素进行近似。</p><p>这个方法用于原始图像的缩放、转换、旋转和裁剪。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.size)imtra = im.transform((200, 200), Image.AFFINE, (1,2,3,2,1,4))print(imtra.size)imtra.show()</code></pre><p>④</p><pre><code>im.transform(size,QUAD, data) ⇒ imageim.transform(size, QUAD, data, filter) ⇒ image</code></pre><p>输入图像的一个<strong>四边形（通过四个角定义的区域）映射到给定尺寸的长方形</strong>。变量data是一个8元组(x0,y0,x1,y1,x2,y2,x3,y3)，它包括源四边形的左上，左下，右下和右上四个角。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.size)imtra = im.transform((200, 200), Image.QUAD, (0,0,0,500,600,500,600,0))print(imtra.size)imtra.show()</code></pre><p>⑤</p><pre><code>im.transform(size,PERSPECTIVE, data) ⇒ imageim.transform(size, PERSPECTIVE, data, filter) ⇒ image</code></pre><p>对当前图像进行<strong>透视变换</strong>，产生给定尺寸的新图像。变量data是一个8元组(a,b,c,d,e,f,g,h)，包括一个透视变换的系数。对于输出图像中的每个像素点，新的值来自于输入图像的位置的(a x + b y + c)/(g x + h y + 1), (d x+ e y + f)/(g x + h y + 1)像素，使用最接近的像素进行近似。</p><p>这个方法用于原始图像的2D透视。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)print(im.size)imtra = im.transform((200, 200), Image.PERSPECTIVE, (1,2,3,2,1,6,1,2))print(imtra.size)imtra.show()</code></pre><h3 id="2-2-31-transpose方法"><a href="#2-2-31-transpose方法" class="headerlink" title="2.2.31 transpose方法"></a>2.2.31 transpose方法</h3><pre><code>im.transpose(method)⇒ image</code></pre><p>返回当前图像的<strong>翻转或者旋转</strong>的拷贝。变量方法的取值为：FLIP_LEFT_RIGHT，FLIP_TOP_BOTTOM，ROTATE_90，ROTATE_180，或ROTATE_270。</p><pre><code>from PIL import Imageim = Image.open(&quot;3d.jpg&quot;)im.show()im1=im.rotate(45)im1.show()#逆时针旋转 45 度角。im2=im.transpose(Image.FLIP_LEFT_RIGHT)#左右对换im2.show()im3=im.transpose(Image.FLIP_TOP_BOTTOM)#上下对换。im3.show()im4=im.transpose(Image.ROTATE_90)#旋转 90 度角。im4.show()im5=im.transpose(Image.ROTATE_180)#旋转 180 度角。im5.show()im6=im.transpose(Image.ROTATE_270)#旋转 270 度角。im6.show()           </code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分类性能提升方案</title>
      <link href="/2020/11/23/My-Post1/"/>
      <url>/2020/11/23/My-Post1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据方面的改进"><a href="#1-数据方面的改进" class="headerlink" title="1 数据方面的改进"></a>1 数据方面的改进</h1><h2 id="1-1-使用EDA-图像预处理"><a href="#1-1-使用EDA-图像预处理" class="headerlink" title="1.1 使用EDA+图像预处理"></a>1.1 使用EDA+图像预处理</h2><p>每一个机器学习/深度学习解决方案都从原始数据开始。在数据处理管道中有两个基本步骤。</p><p>第一步是<strong>探索性数据分析 (EDA)</strong>。它帮助我们分析整个数据集并总结它的主要特征，比如类分布、大小分布等等。通常使用可视化方法来显示这种分析的结果。</p><p>第二步是<strong>图像预处理</strong>，目的是对原始图像提高图像数据(也称为图像特征)的质量，通过抑制不必要的扭曲，缩放，增强重要的特征，使数据更适合模型并提高性能。</p><p>你可以钻研这些Kaggle笔记本，看看一些图像预处理技术：</p><ul><li><p>Visualisation：<a href="https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline#Building-a-baseline-model-" target="_blank" rel="noopener">https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline#Building-a-baseline-model-</a></p></li><li><p>Dealing with Class imbalance：<a href="https://www.kaggle.com/rohandeysarkar/ultimate-image-classification-guide-2020" target="_blank" rel="noopener">https://www.kaggle.com/rohandeysarkar/ultimate-image-classification-guide-2020</a></p></li><li><p>Fill missing values(labels, features and, etc.)：<a href="https://www.kaggle.com/datafan07/analysis-of-melanoma-metadata-and-effnet-ensemble" target="_blank" rel="noopener">https://www.kaggle.com/datafan07/analysis-of-melanoma-metadata-and-effnet-ensemble</a></p></li><li><p>Normalisation ：<a href="https://www.kaggle.com/vincee/intel-image-classification-cnn-keras" target="_blank" rel="noopener">https://www.kaggle.com/vincee/intel-image-classification-cnn-keras</a></p></li><li><p>Pre-processing：<a href="https://www.kaggle.com/ratthachat/aptos-eye-preprocessing-in-diabetic-retinopathy#3.A-Important-Update-on-Color-Version-of-Cropping-&amp;-Ben&#39;s-Preprocessing" target="_blank" rel="noopener">https://www.kaggle.com/ratthachat/aptos-eye-preprocessing-in-diabetic-retinopathy#3.A-Important-Update-on-Color-Version-of-Cropping-&amp;-Ben&#39;s-Preprocessing</a></p></li></ul><h2 id="1-2-使用数据增强"><a href="#1-2-使用数据增强" class="headerlink" title="1.2 使用数据增强"></a>1.2 使用数据增强</h2><p>数据增强可以通过从现有的训练样本中生成更多的训练数据来<strong>扩展我们的数据集</strong>。通过大量的随机转换生成新的样本，这些转换不仅可以生成可信的图像，而且还反映了真实的场景。</p><p>通常，当一个模型在训练数据上表现很好，但在验证数据上表现很差时，我们称之为过拟合。为了解决这个问题，我们通常会尝试获取新数据，如果没有可用的新数据，则可以使用数据增强。</p><p>注：一般的经验法则是始终使用数据增强技术，因为它有助于使我们的模型见识更多的变化并更好地泛化。即使我们有一个很大的数据集，也要使用数据增强，但这是以较慢的训练速度为代价的，因为增强是在线完成的(即在训练期间)。</p><p>此外，对于每个任务或数据集，我们必须使用反映可能的现实场景的增强技术(例如，如果我们有一个猫/狗探测器，我们可以使用水平翻转、剪裁、亮度和对比度)，因为这些增强匹配不同的照片拍摄方式。</p><p><strong>Pytroch图像增强方法</strong>。使用pytorch中的图像预处理包torchvision.transforms，一般用Compose把多个步骤整合到一起，常见步骤有：</p><p>1.裁剪—Crop</p><p>中心裁剪：transforms.CenterCrop</p><p>随机裁剪：transforms.RandomCrop</p><p>随机长宽比裁剪：transforms.RandomResizedCrop</p><p>上下左右中心裁剪：transforms.FiveCrop</p><p>上下左右中心裁剪后翻转，transforms.TenCrop</p><p>2.翻转和旋转—Flip and Rotation</p><p>依概率p水平翻转：transforms.RandomHorizontalFlip(p=0.5)</p><p>依概率p垂直翻转：transforms.RandomVerticalFlip(p=0.5)</p><p>随机旋转：transforms.RandomRotation</p><p>3.图像变换</p><p>resize：transforms.Resize</p><p>标准化：transforms.Normalize</p><p>转为tensor,并归一化至[0-1]：transforms.ToTensor</p><p>填充：transforms.Pad</p><p>修改亮度、对比度和饱和度：transforms.ColorJitter</p><p>转灰度图：transforms.Grayscale</p><p>线性变换：transforms.LinearTransformation()</p><p>仿射变换：transforms.RandomAffine</p><p>依概率p转为灰度图：transforms.RandomGrayscale</p><p>将数据转换为PILImage：transforms.ToPILImage</p><p>transforms.Lambda：Apply a user-defined lambda as a transform.</p><p>4.对transforms操作，使数据增强更灵活</p><p>transforms.RandomChoice(transforms)，从给定的一系列transforms中选一个进行操作</p><p>transforms.RandomApply(transforms, p=0.5)，给一个transform加上概率，依概率进行操作</p><p>transforms.RandomOrder，将transforms中的操作随机打乱</p><p>这里是一些Kaggle笔记本，你可以查看流行的数据增强技术：</p><ul><li><p>Horizontal Flip：<a href="https://www.kaggle.com/datafan07/analysis-of-melanoma-metadata-and-effnet-ensemble" target="_blank" rel="noopener">https://www.kaggle.com/datafan07/analysis-of-melanoma-metadata-and-effnet-ensemble</a></p></li><li><p>Random Rotate and Random Dihedral：<a href="https://www.kaggle.com/iafoss/pretrained-resnet34-with-rgby-0-460-public-lb" target="_blank" rel="noopener">https://www.kaggle.com/iafoss/pretrained-resnet34-with-rgby-0-460-public-lb</a></p></li><li><p>Hue, Saturation, Contrast, Brightness, Crop：<a href="https://www.kaggle.com/cdeotte/triple-stratified-kfold-with-tfrecords" target="_blank" rel="noopener">https://www.kaggle.com/cdeotte/triple-stratified-kfold-with-tfrecords</a></p></li><li><p>Colour jitter：<a href="https://www.kaggle.com/nroman/melanoma-pytorch-starter-efficientnet" target="_blank" rel="noopener">https://www.kaggle.com/nroman/melanoma-pytorch-starter-efficientnet</a></p></li></ul><h1 id="2-模型的改进"><a href="#2-模型的改进" class="headerlink" title="2 模型的改进"></a>2 模型的改进</h1><h2 id="2-1-先开发一个基线"><a href="#2-1-先开发一个基线" class="headerlink" title="2.1 先开发一个基线"></a>2.1 先开发一个基线</h2><p>在这里，我们使用一个非常简单的架构创建一个基本的模型，没有任何正则化或dropout层，看看我们是否能超过50%的<strong>准确率基线</strong>。尽管我们不可能总能达到这个目标，但如果我们在尝试了多种合理的架构后不能超过基线，那么输入数据可能不包含模型进行预测所需的信息。</p><p>用Jeremy Howard的名言：<br>“你应该能够在15分钟内使用50%或更少的数据集快速测试你是否正在朝着一个有希望的方向前进，如果没有，你必须重新考虑一切。”</p><h2 id="2-2-试着开发一个足够大过拟合的模型"><a href="#2-2-试着开发一个足够大过拟合的模型" class="headerlink" title="2.2 试着开发一个足够大过拟合的模型"></a>2.2 试着开发一个足够大过拟合的模型</h2><p>一旦我们的基线模型有足够的能力超过基线分数，我们就可以增加基线模型的能力，直到它在数据集上<strong>过拟合为止</strong>，然后我们就开始应用正则化。</p><p>我们可以通过以下方式增加模块容量：</p><ol><li>添加更多层</li><li>使用更好的结构</li><li>更完善的训练流程</li></ol><h2 id="2-3-模型结构调整"><a href="#2-3-模型结构调整" class="headerlink" title="2.3 模型结构调整"></a>2.3 模型结构调整</h2><p>根据文献，以下<strong>架构的改进</strong>提高了模型的容量，但几乎没有改变计算复杂度。</p><ul><li><p>Residual Networks</p></li><li><p>Wide Residual Networks</p></li><li><p>Inception</p></li><li><p>EfficientNet</p></li><li><p>Swish activation</p></li><li><p>Residual Attention Network</p></li></ul><p>大多数时候，模型容量和精度是正相关的 —— 随着容量的增加，精度也会增加，反之亦然。</p><h2 id="2-4-改进训练过程"><a href="#2-4-改进训练过程" class="headerlink" title="2.4 改进训练过程"></a>2.4 改进训练过程</h2><p>下面是一些你可以用来调整你的模型的<strong>训练过程</strong>，通过实例项目来看看它们是如何工作的：</p><ul><li><p>Mixed-Precision Training</p></li><li><p>Large Batch-Size Training</p></li><li><p>Cross-Validation Set</p></li><li><p>Weight Initialization</p></li><li><p>Self-Supervised Training(Knowledge Distillation)</p></li><li><p>Learning Rate Scheduler</p></li><li><p>Learning Rate Warmup</p></li><li><p>Early Stopping</p></li><li><p>Differential Learning Rates</p></li><li><p>Ensemble</p></li><li><p>Transfer Learning</p></li><li><p>Fine-Tuning</p></li></ul><h2 id="2-5-超参数的调试"><a href="#2-5-超参数的调试" class="headerlink" title="2.5 超参数的调试"></a>2.5 超参数的调试</h2><p>与参数不同，hyperparameters是由你在配置模型时指定的(即学习率、epoch的数量、hidden units的数量、batch size大小等)。</p><p>你可以通过使用<strong>hyperparameter调优库</strong>，比如Scikit learn Grid Search，Keras Tuner来自动化这个过程，而不是去手动配置。这些库会在你指定的范围内尝试所有的hyperparameter组合，返回表现最好的模型。</p><p>需要调优的超参数越多，过程就越慢，因此最好选择模型超参数的最小子集进行调优。</p><p>并不是所有的模型超参数都同样重要。一些超参数会对机器学习算法的行为产生巨大的影响，进而影响其性能。你应该小心地选择那些对模型性能影响最大的参数，并对它们进行调优以获得最佳性能。</p><h2 id="2-6-添加正则化"><a href="#2-6-添加正则化" class="headerlink" title="2.6 添加正则化"></a>2.6 添加正则化</h2><p>这种方法迫使模型学习有意义和具有泛化能力的数据表示，通过<strong>对记忆/过拟合和欠拟合进行惩罚</strong>来实现，使模型对于它没见过的数据更鲁棒。</p><p>解决上述问题的一个简单方法是获得更多的训练数据，因为一个模型训练的数据越多，自然就会泛化得越好。</p><p>这里有一些技巧你可以试着减轻过拟合和欠拟合，项目如下：</p><ul><li><p>Adding Dropout：<a href="https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline" target="_blank" rel="noopener">https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline</a></p></li><li><p>Adding or changing the position of Batch Norm：<a href="https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline" target="_blank" rel="noopener">https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline</a></p></li><li><p>Data augmentation：<a href="https://www.kaggle.com/cdeotte/triple-stratified-kfold-with-tfrecords" target="_blank" rel="noopener">https://www.kaggle.com/cdeotte/triple-stratified-kfold-with-tfrecords</a></p></li><li><p>Mixup：<a href="https://arxiv.org/abs/1710.09412" target="_blank" rel="noopener">https://arxiv.org/abs/1710.09412</a></p></li><li><p>Weight regularization：<a href="https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline" target="_blank" rel="noopener">https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline</a></p></li><li><p>Gradient clipping：<a href="https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline" target="_blank" rel="noopener">https://www.kaggle.com/allunia/protein-atlas-exploration-and-baseline</a></p></li></ul><h2 id="2-7-改进损失函数"><a href="#2-7-改进损失函数" class="headerlink" title="2.7 改进损失函数"></a>2.7 改进损失函数</h2><p>损失函数也被称为成本函数或目标函数，用于<strong>查找目标输出的模型之间的差异</strong>，并帮助模型最小化它们之间的距离。</p><p>这里是一些最流行的损失函数与项目实例，你会发现一些技巧，以提高你的模型的能力：</p><ul><li><p>Label smoothing</p></li><li><p>Focal loss</p></li><li><p>SparseMax loss and Weighted cross-entropy</p></li><li><p>BCE loss, BCE with logits loss and Categorical cross-entropy loss</p></li><li><p>Additive Angular Margin Loss for Deep Face Recognition</p></li></ul><h1 id="3-对模型进行评估-错误分析"><a href="#3-对模型进行评估-错误分析" class="headerlink" title="3 对模型进行评估+错误分析"></a>3 对模型进行评估+错误分析</h1><p>在这里，我们做<strong>消融研究</strong>，并分析我们的实验结果。我们确定了我们的模型的弱点和长处，并确定了未来需要改进的地方。</p><p>在这个阶段，你可以使用以下技术，并在链接的示例中查看它们是如何实现的：</p><ul><li><p>Tracking metrics and Confusion matrix：<a href="https://www.kaggle.com/vincee/intel-image-classification-cnn-keras" target="_blank" rel="noopener">https://www.kaggle.com/vincee/intel-image-classification-cnn-keras</a></p></li><li><p>Grad CAM：<a href="https://arxiv.org/pdf/1610.02391v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1610.02391v1.pdf</a></p></li><li><p>Test Time Augmentation(TTA)：<a href="https://www.kaggle.com/iafoss/pretrained-resnet34-with-rgby-0-460-public-lb" target="_blank" rel="noopener">https://www.kaggle.com/iafoss/pretrained-resnet34-with-rgby-0-460-public-lb</a></p></li></ul><p>有许多实验跟踪和管理工具，采取最小设置为你自动保存所有数据，这使消融研究更容易。</p><p>有许多方法来调整你的模型，并且新的想法总是会出现。深度学习是一个快速发展的领域，没有什么灵丹妙药。我们必须做很多实验，足够的试验和错误会带来突破。</p><h1 id="4-寻找创新策略"><a href="#4-寻找创新策略" class="headerlink" title="4 寻找创新策略"></a>4 寻找创新策略</h1><h2 id="4-1-迁移学习-微调"><a href="#4-1-迁移学习-微调" class="headerlink" title="4.1 迁移学习-微调"></a>4.1 迁移学习-微调</h2><p><strong>迁移学习</strong>将从源数据集学到的知识迁移到目标数据集。常见的迁移学习方法有：</p><p>1.载入权重后训练所有参数。</p><p>2.载入权重后只训练最后几层参数。</p><p>3.载入权重后在原网络基础上再添加一层全连接层，仅训练最后一个全连接层。</p><p>注意：使用别人预训练模型时，要和它的预处理方式保持一致。</p><p><strong>微调</strong>（迁移学习的常用技术）的步骤：</p><p>1.在源数据集（如ImageNet数据集）上预训练一个神经网络模型，即源模型。</p><p>2.创建一个新的神经网络模型，即目标模型。它复制了源模型上除了输出层外的所有模型设计及其参数。我们假设这些模型参数包含了源数据集上学习到的知识，且这些知识同样适用于目标数据集。我们还假设源模型的输出层与源数据集的标签紧密相关，因此在目标模型中不予采用。</p><p>3.为目标模型添加一个输出大小为目标数据集类别个数的输出层，并随机初始化该层的模型参数。</p><p>4.在目标数据集上训练目标模型。我们将从头训练输出层，而其余层的参数都是基于源模型的参数微调得到的。</p><h2 id="4-2-知识蒸馏"><a href="#4-2-知识蒸馏" class="headerlink" title="4.2 知识蒸馏"></a>4.2 知识蒸馏</h2><p><strong>知识蒸馏</strong>是将一个已经训练好的网络迁移到另外一个新网络，常采用teacher-student学习策略，已经被广泛应用在<strong>模型压缩</strong>和<strong>迁移学习</strong>中。</p><p>例如，MEAL V2是通过知识蒸馏提升ResNet50在ImageNet上的分类准确度，MEAL V2不需要修改网络结构，也不需要其他特殊的训练策略和数据增强就可以使原始ResNet50的Top-1准确度提升至80%+。</p><p>MEAL V2主要的思路是将<strong>多个模型的集成效果</strong>通过知识蒸馏迁移到一个单一网络中，整个设计非常简单，只包括三个重要的部分：teacher模型集成，KL散度loss以及一个判别器。</p><p>MEAL V2采用对抗学习来防止student在训练数据上过拟合，即不让student过分学习teacher的输出，这其实是一种正则化手段。</p><p>有一点需要注意，在蒸馏时，ResNet50不是随机初始化的，而是从预训练好的ImageNet模型进行初始化，就是说student也需要一个好的初始化，如果是随机初始化可能需要更长的训练时长。</p><p>在最新的无监督方法研究如谷歌的SimCLRv2和Noisy Student均有知识蒸馏的身影。</p><blockquote><p>参考：</p><p>1.MEAL V2: Boosting Vanilla ResNet-50 to 80%+ Top-1 Accuracy on ImageNet without Tricks∗</p><p>2.MEAL: Multi-Model Ensemble via Adversarial Learning</p><p>3.Distilling the Knowledge in a Neural Network</p><p>4.szq0214/MEAL-V2</p></blockquote><h1 id="一些项目实例"><a href="#一些项目实例" class="headerlink" title="一些项目实例"></a>一些项目实例</h1><p>这里从Kaggle比赛中挑选出了好的Kaggle kernel。这些比赛是:</p><ul><li>Intel Image Classification: <a href="https://www.kaggle.com/puneet6060/intel-image-classification" target="_blank" rel="noopener">https://www.kaggle.com/puneet6060/intel-image-classification</a></li></ul><ul><li>Recursion Cellular Image Classification: <a href="https://www.kaggle.com/c/recursion-cellular-image-classification" target="_blank" rel="noopener">https://www.kaggle.com/c/recursion-cellular-image-classification</a></li></ul><ul><li>SIIM-ISIC Melanoma Classification: <a href="https://www.kaggle.com/c/siim-isic-melanoma-classification" target="_blank" rel="noopener">https://www.kaggle.com/c/siim-isic-melanoma-classification</a></li></ul><ul><li>APTOS 2019 Blindness Detection: <a href="https://www.kaggle.com/c/aptos2019-blindness-detection/notebooks" target="_blank" rel="noopener">https://www.kaggle.com/c/aptos2019-blindness-detection/notebooks</a></li></ul><ul><li>Diabetic Retinopathy Detection: <a href="https://www.kaggle.com/c/diabetic-retinopathy-detection" target="_blank" rel="noopener">https://www.kaggle.com/c/diabetic-retinopathy-detection</a></li></ul><ul><li>ML Project—Image Classification: <a href="https://www.kaggle.com/c/image-classification-fashion-mnist/notebooks" target="_blank" rel="noopener">https://www.kaggle.com/c/image-classification-fashion-mnist/notebooks</a></li></ul><ul><li>Cdiscount’s Image Classification Challenge: <a href="https://www.kaggle.com/c/cdiscount-image-classification-challenge/notebooks" target="_blank" rel="noopener">https://www.kaggle.com/c/cdiscount-image-classification-challenge/notebooks</a></li></ul><ul><li>Plant seedlings classifications: <a href="https://www.kaggle.com/c/plant-seedlings-classification/notebooks" target="_blank" rel="noopener">https://www.kaggle.com/c/plant-seedlings-classification/notebooks</a></li></ul><ul><li>Aesthetic Visual Analysis: <a href="https://www.kaggle.com/c/aesthetic-visual-analysis/notebooks" target="_blank" rel="noopener">https://www.kaggle.com/c/aesthetic-visual-analysis/notebooks</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书学习记录</title>
      <link href="/2020/10/25/My-Post2/"/>
      <url>/2020/10/25/My-Post2/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-模型评估与模型选择"><a href="#第2章-模型评估与模型选择" class="headerlink" title="第2章 模型评估与模型选择"></a>第2章 模型评估与模型选择</h1><p>1.数据集<strong>评估方法</strong>：留出法，k折交叉验证法，自助采样。</p><p>2.模型<strong>性能度量</strong>：均方误差，错误率，精度；查准率、查全率、混淆矩阵、P-R曲线和F1度量；ROC曲线和AUC；代价矩阵、代价敏感错误率和代价曲线。 <a href="https://zhuanlan.zhihu.com/p/137305152" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/137305152</a></p><p>3.<strong>统计假设检验</strong>：单个算法采用二项检验和t检验，两个算法采用交叉验证t检验和McNemar检验，多个算法采用两两比较检验方法，或者Friedman检验+Nemenyi后续检验。</p><p>4.利用<strong>偏差-方差分解</strong>来查看算法的泛化能力，缓解过拟合的方法：权重衰减（通过在⽬标函数后添加L2范数惩罚项来实现权重衰减）和正则化。</p><h1 id="第3章-线性模型"><a href="#第3章-线性模型" class="headerlink" title="第3章 线性模型"></a>第3章 线性模型</h1><p>1.线性回归和多元线性回归，利用最小二乘法和引入正则化进行模型求解。</p><p>2.线性回归模型和广义线性模型（对数线性回归模型和Sigmoid函数形成的logistic回归模型）。</p><p>3.<strong>二分类任务</strong>的logistic回归方法和LDA(线性判别分析)方法，<strong>多分类任务</strong>的OvO、OvR、MvM方法和纠错输出码技术ECOC，如何处理分类问题中类别不平衡问题。多分类的logistic回归叫softmax回归。</p><h1 id="第4章-决策树"><a href="#第4章-决策树" class="headerlink" title="第4章 决策树"></a>第4章 决策树</h1><p>1.<strong>生成决策树</strong>（划分选择）的三种算法：ID3，C4.5和CART。</p><p>2.<strong>剪枝</strong>方法：预剪枝和后剪枝。</p><p>3.如何处理<strong>连续</strong>属性（二分法），如何处理样本存在<strong>缺失值</strong>的方法。</p><p>4.决策树的升级：多变量决策树（斜决策树）。</p><h1 id="第5章-神经网络"><a href="#第5章-神经网络" class="headerlink" title="第5章 神经网络"></a>第5章 神经网络</h1><p>1.M-P神经元，感知机（只有一层功能神经元），多层感知机（有多层功能神经元），<strong>多层前馈神经网络</strong>。</p><p>2.<strong>BP算法</strong>：计算梯度，更新连接权和阈值，计算误差，根据误差调整连接权和阈值，不断迭代<strong>寻找最优参数使误差最小</strong>。缓解BP网络过拟合的方法：早停和正则化。BP算法的改进：自适应缩小学习率等。</p><p>3.“最优”：局部极小和<strong>全局最小</strong>，跳过局部最优寻找全局最优方法：模拟退火、随机梯度下降SGD和遗传算法，用局部最优代替全局最优方法：贪心算法。</p><p>4.常见神经网络：RBF网络（径向基函数），ART网络（算法族:ART2网络、FuzzyART网络、ARTMAP网络等），SOM网络（高维映射到低维），级联相关网络（结构自适应），Elman网络（递归神经网络），Boltzmann机（基于能量的模型、递归神经网络，常用的是RBM(CD算法训练)）。</p><h1 id="第6章-支持向量机SVM"><a href="#第6章-支持向量机SVM" class="headerlink" title="第6章 支持向量机SVM"></a>第6章 支持向量机SVM</h1><p>1.二分类任务：划分超平面，支持向量，间隔(训练目的:找到具有最大间隔的划分超平面)-&gt;<strong>支持向量机</strong>(优化目标)</p><p>2.求解过程：用拉格朗日乘子法得到对偶问题(二次规划问题)，二次规划算法、SOM算法(固定其他参数，仅优化两个参数，求得优化后的参数)，最终得到模型参数，求得支持向量机模型。</p><p>3.训练样本不是线性可分的：将样本映射到一个更高维的特征空间，通过训练样本的<strong>核函数</strong>求模型最优解。核函数的选择，常用核函数及它们的组合。</p><p>4.现实任务很难确定合适的核函数使训练样本在特征空间中线性可分：<strong>软间隔支持向量机</strong>（引入松弛变量和损失函数(0/1损失函数、hinge损失函数、指数损失函数、对率损失函数)允许支持向量机在一些样本上出错）</p><p>5.回归问题：<strong>支持向量回归SVR</strong>（引入松弛变量和ε-不敏感损失函数，允许模型输出和真实输出有ε的误差）</p><p>6.核方法(基于核函数的学习方法)，KLDA(核线性判别分析)方法</p><h1 id="第7章-贝叶斯分类器"><a href="#第7章-贝叶斯分类器" class="headerlink" title="第7章 贝叶斯分类器"></a>第7章 贝叶斯分类器</h1><p>1.贝叶斯决策论，<strong>贝叶斯最优分类器</strong>：估计类先验概率(样本频率)和类条件概率(极大似然估计法)代入公式求解。</p><p>2.<strong>朴素贝叶斯分类器</strong>(所有属性相互独立)：估计类先验概率和每个属性的条件概率代入公式求解，拉普拉斯修正。</p><p>3.<strong>半朴素贝叶斯分类器</strong>(每个属性在类别之外最多仅依赖于一个其他属性)：独依赖估计(SPODE方法、TAN方法和AODE方法)和k依赖估计。</p><p>4.<strong>贝叶斯网</strong>：由结构(有向无环图或道德图-表示属性的依赖关系)和参数(包含每个属性的条件概率表)组成。学习任务：寻找结构最优-&gt;综合编码长度最短(最小描述长度准则)-&gt;评分函数最小(评分搜索方法)的贝叶斯网。方法：对参数进行极大似然估计。贝叶斯网近似推断：吉布斯采样算法和马尔可夫链。</p><p>5.训练样本含隐变量：<strong>EM算法</strong>(推断期望和最大似然估计并不断迭代)。</p><h1 id="第8章-集成学习"><a href="#第8章-集成学习" class="headerlink" title="第8章 集成学习"></a>第8章 集成学习</h1><p>1.个体与集成：个体学习器间存在强依赖关系<strong>Boosting算法</strong>(AdaBoost算法:重赋权值+重采样法,优化目标:最小化指数损失函数);个体学习器间不存在强依赖关系<strong>Bagging</strong>(自助采样法,包外估计)和<strong>随机森林</strong>(Bagging+随机属性选择)。</p><p>2.基学习器结合的好处和<strong>结合策略</strong>(平均法、投票法、学习法)。</p><p>3.<strong>误差-分歧分解</strong>：个体学习器准确率越高、多样性越大则集成越好。<strong>多样性度量</strong>方法：不合度量、相关系数、Q-统计量、k-统计量。<strong>多样性增强</strong>方法：数据样本扰动(采样法)、输入属性扰动(随机子空间算法)、输出表示扰动(翻转法、输出调制法、ECOC法)、算法参数扰动(负相关法)。</p><h1 id="第9章-聚类"><a href="#第9章-聚类" class="headerlink" title="第9章 聚类"></a>第9章 聚类</h1><p>1.聚类性能度量：外部指标(Jaccard系数、FM指数、Rand指数),内部指标(DB指数、Dunn指数)。</p><p>2.<strong>距离计算</strong>：有序属性采用闵可夫斯基距离，无序属性采用VDM，集合间距离采用豪斯多夫距离。非度量距离(模式识别、图像检索)，距离度量学习。</p><p>3.原型聚类：<strong>K-means聚类</strong>算法(采用贪心策略迭代优化使误差最小)、学习向量量化<strong>LVQ</strong>(根据距离+标记进行更新)、<strong>高斯混合聚类</strong>(采用概率模型对原型进行刻画-EM算法对模型参数迭代更新)。</p><p>4.<strong>密度聚类</strong>：DBSCAN算法(基于邻域参数刻画样本分布的紧密程度,由紧密程度确定聚类结构)。</p><p>5.<strong>层次聚类</strong>：AGNES算法(自底向上聚合,不断合并距离最近的聚类簇并更新距离矩阵,形成树形的聚类结构)</p><h1 id="第10章-降维与度量学习"><a href="#第10章-降维与度量学习" class="headerlink" title="第10章 降维与度量学习"></a>第10章 降维与度量学习</h1><p>1.<strong>k近邻学习</strong>(kNN-先把训练样本保存，给定测试样本后基于某种距离度量找出训练集中与其最靠近的k个训练样本，基于此进行预测)。</p><p>2.线性降维方法(对原始高维空间进行线性变换)：<strong>多维缩放MDS，主成分分析PCA</strong>(最近重构性，最大可分性，步骤：中心化-&gt;协方差矩阵-&gt;特征值分解/奇异值分解-&gt;取特征值大的特征向量)，线性判别分析LDA</p><p>3.非线性降维方法：<strong>核主成分分析</strong>(基于核技巧对线性降维方法进行‘核化’，引入核函数-&gt;特征值分解)，核线性判别分析KLDA</p><p>4.流形学习：<strong>等度量映射Isomap</strong>(构建近邻连接图，将测地线距离转变为计算近邻连接图上两点之间的最短路径-Dijkstra算法和Floyd算法)，<strong>局部线性嵌入LLE</strong>(寻找样本点的领域样本点集-&gt;得到线性重构系数-&gt;计算协方差矩阵M-&gt;特征值分解-&gt;取M最小的一定个数特征值对应的特征向量组成的矩阵即可得到样本点的低维空间投影坐标)</p><p>5.<strong>度量学习</strong>：通过学习找到合适的距离度量矩阵M(近邻成分分析方法NCA：求解优化目标即可得到使留一法正确率最大化的距离度量矩阵)，对M进行特征值分解进行降维。</p><h1 id="第11章-特征选择与稀疏学习"><a href="#第11章-特征选择与稀疏学习" class="headerlink" title="第11章 特征选择与稀疏学习"></a>第11章 特征选择与稀疏学习</h1><p>1.特征选择方法：<strong>子集搜索</strong>(贪心的前向搜索、后向搜索、双向搜素)+<strong>子集评价</strong>(基于训练数据计算候选特征子集的信息增益)</p><p>2.特征选择类型：<strong>过滤式</strong>(先特征选择再训练学习器，如Relief用相关统计量(根据猜中近邻值和猜错近邻值来不断调整统计量分量)来度量特征的重要性-二分类问题，Relief-F能处理多分类问题)、<strong>包裹式</strong>(直接针对给定学习器进行优化，如LVM算法(子集搜素：拉斯维加斯框架下随机策略；子集评价：最终分类器的误差-由交叉验证法得到))、<strong>嵌入式</strong>（将特征选择过程与学习器训练过程融为一体，线性回归模型引入正则化：L1范数正则化(LASSO-&gt;求w，优化目标求解：考虑L1范数最小化的近端梯度下降法)比L2范数正则化(岭回归)更易于得到稀疏解）。</p><p>3.<strong>字典学习</strong>与稀疏编码：学得一个字典(求字典矩阵B)-&gt;对样本进行<strong>稀疏表达</strong>(求样本xi的稀疏表示ɑi)，用户能通过控制字典规模从而影响稀疏程度。优化目标求解：基于逐列更新策略的KSVD，采用保留稀疏性的奇异值分解方法。</p><p>4.<strong>压缩感知</strong>：基于部分信息恢复全部信息（对部分信息处理获得稀疏样本表示(傅里叶变换、小波变换、字典学习和稀疏编码)-&gt;基于稀疏性恢复原始信号），压缩感知问题求解=L1范数最小化问题求解(使用基寻踪去噪)，矩阵补全技术(最小化矩阵核范数-凸优化问题-半正定规划SDP)</p><h1 id="第12章-计算学习理论"><a href="#第12章-计算学习理论" class="headerlink" title="第12章 计算学习理论"></a>第12章 计算学习理论</h1><p>1.<strong>PAC学习</strong>：概念类C，假设空间H，学习算法ε</p><p>2.度量假设空间的复杂度：<strong>VC维</strong>，<strong>Rademacher复杂度</strong>(一定程度上考虑了数据分布)；与算法有关的分析：稳定性分析</p><h1 id="第13章-半监督学习"><a href="#第13章-半监督学习" class="headerlink" title="第13章 半监督学习"></a>第13章 半监督学习</h1><p>1.半监督学习：让学习器不依赖外界交互、自动地利用未标记样本来提升学习性能。(采用<strong>主动学习</strong>，引入<strong>专家知识</strong>，可通过与外界的交互来将部分未标记样本转变为有标记样本)</p><p>2.半监督学习思路：<strong>聚类假设、流形假设</strong>(本质：相似的样本具有相似的输出)。半监督学习 = 纯半监督学习(未标记样本≠待预测数据)+直推学习(未标记样本=待预测数据)</p><p>3.半监督学习<strong>四大范型</strong>：生成式半监督学习方法，半监督SVM，图半监督学习(标记传播算法)，基于分歧的方法(多学习器，协同训练)</p><p>4.聚类是无监督学习任务，半监督聚类：约束k均值算法，约束种子k均值算法。</p><h1 id="第14章-概率图模型"><a href="#第14章-概率图模型" class="headerlink" title="第14章 概率图模型"></a>第14章 概率图模型</h1><p>1.概率模型-&gt;<strong>概率图模型</strong>有两类：①有向图模型=贝叶斯网：<strong>隐马尔可夫</strong>模型，话题模型-生成式模型(处理离散型数据例如文本集合，隐狄利克雷分配模型LDA)；②无向图模型=<strong>马尔可夫网</strong>：马尔可夫随机场MRF，条件随机场CRF-判别式模型。</p><p>2.推断：利用已知变量推断未知变量的分布。概率图模型的推断方法：①精确推断法(<strong>动态规划</strong>)：变量消去法，信念传播算法；②近似推断法：采样<strong>(马尔可夫链蒙特卡洛</strong>MCMC方法-Metropolis-Hastings算法)，确定性近似(变分推断)。</p><h1 id="第15章-规则学习"><a href="#第15章-规则学习" class="headerlink" title="第15章 规则学习"></a>第15章 规则学习</h1><p>1.规则学习：从训练数据中学习出一组能用于对未见实例进行判别的规则。规则可分为两类：命题规则和一阶规则。</p><p>2.规则学习的目标：产生一个能<strong>覆盖尽可能多的样例</strong>的规则集。<strong>序贯覆盖</strong>(规则学习的基本框架)：逐条归纳，分治策略。<strong>剪枝优化</strong>：缓解过拟合风险，预剪枝(统计显著性检验-CN2算法)，后剪枝(减错剪枝REP-IREF算法、RIPPER算法)。</p><p>3.命题规则学习，<strong>一阶规则学习</strong>(FOIL算法:遵循序贯覆盖框架采用自顶向下的规则归纳策略)，<strong>归纳逻辑程序设计</strong>(关系学习)：在一阶规则学习中引入了函数和逻辑表达式嵌套，采用自底向上的规则生成策略(最小一般泛化，逆归结)。</p><h1 id="第16章-强化学习"><a href="#第16章-强化学习" class="headerlink" title="第16章 强化学习"></a>第16章 强化学习</h1><p>1.强化学习：找到能使长期累积奖赏最大化的策略(T步累积奖赏，γ折扣累积奖赏)，通常用<strong>马尔可夫决策过程MDP</strong>来描述。</p><p>2.单步强化学习任务-&gt;<strong>K-摇臂赌博机</strong>：仅探索法(概率估计摇臂的优劣)，仅利用法(选择当前最优摇臂)，ε贪心算法(基于一个概率对探索和利用进行折中)，Softmax算法(基于当前已知的摇臂平均奖赏来对探索和利用进行折中)。</p><p>3.多步强化学习任务-&gt;<strong>有模型学习</strong>(基于动态规划的寻优问题)：策略评估、策略改进、策略迭代与值迭代。-&gt;<strong>免模型学习</strong>：蒙特卡罗强化学习(进行策略评估和策略改进)，分为同策略和异策略。-&gt;<strong>时序差分TD学习</strong>：结合动态规划与蒙特卡罗方法(Sarsa算法-同策略，Q-学习算法-异策略)</p><p>4.连续状态空间：<strong>值函数近似法</strong>(线性值函数近似Sarsa算法，线性值函数近似Q-学习算法)。</p><p>5.模仿学习(从人类专家的决策过程<strong>范例中学习</strong>)：直接模仿学习(直接模仿人类专家的“状态-动作对”)、逆强化学习(从人类专家提供的范例数据中反推出奖赏函数)</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python GUI开发记录</title>
      <link href="/2020/09/26/My-Post3/"/>
      <url>/2020/09/26/My-Post3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-学习历程"><a href="#1-学习历程" class="headerlink" title="1 学习历程"></a>1 学习历程</h1><p><strong>1.1学习库Tkinter，PySide2和PyQt5</strong></p><p>1.学习<strong>Tkinter</strong>库时跟着视频教程设计了<strong>登录窗口</strong> 并配置了用户数据库，设置了按钮的回调函数，添加了提示窗口，为主界面添加了<strong>菜单栏</strong>并且设置了菜单栏选项的回调函数。    </p><p>2.跟着白月黑羽课程学习<strong>PySide2</strong>库的使用和<strong>Qt Designer</strong>平台的界面布局，学习对GUI窗口的相关操作，了解了常用控件和对应的操作函数，实现了一个小实例-统计薪资水平，学习了用PyInstaller发布程序和为界面添加图标的方法。</p><p>3.PyQt5和PySide2操作类似，且使用更加方便，所以后面的设计采用<strong>PyQt5</strong>来完成，还学习了ui文件转py文件的方法，并且为我的pycharm配置了ui文件转py文件的快捷方式。</p><p><strong>1.2使用Qt Designer搭建信号与系统虚拟实验平台界面</strong></p><p>1.首先按照自己的想法设计了只有<strong>2层的系统界面</strong>，分别是连续和离散信号展示层、包含四个实验的实验层。</p><p>2.然后根据导师的图纸设计了包含<strong>6层的系统界面</strong>（这里只截取了部分界面），具体思路就是将信号展示环节和实验操作环节分开。</p><p><strong>1.3编写界面入口程序添加功能函数</strong></p><p>1.编写整个系统的<strong>入口程序</strong>，该程序连接着系统开始界面。</p><pre><code>app=QtWidgets.QApplication(sys.argv)widget=QtWidgets.QWidget()ui=Ui_widge()ui.setupUi(widget)widget.show()sys.exit(app.exec_())</code></pre><p>2.将每个界面的ui文件转换成py文件，并且通过编写函数为控件添加功能，包括获取文本框的输入文本（文本框输入的是字符串，先用eval函数将其转换为列表或数字）、为按钮添加动作连接函数、获取滑块的值显示到文本框中、为实验添加说明框等等。下面为某个界面的<strong>功能函数和界面转换</strong>代码。</p><pre><code>def zhishu(self):    Form_16 = QtWidgets.QDialog()    self.ui = Ui_Form16()    self.ui.setupUi(Form_16)    Form_16.show()    Form_16.exec_()    self.Form10.show()def close(self):    self.Form10.close()def retranslateUi(self, Form10):    _translate = QtCore.QCoreApplication.translate    Form10.setWindowTitle(_translate(&quot;Form10&quot;, &quot;辅助实验教学子系统 - 信号 - 基本信号&quot;))    Form10.setWindowIcon(QtGui.QIcon(&#39;1.jpg&#39;))    self.pushButton_1.setText(_translate(&quot;Form10&quot;, &quot;指数信号&quot;))    self.pushButton_1.clicked.connect(self.zhishu)    self.pushButton_2.setText(_translate(&quot;Form10&quot;, &quot;返回上一级&quot;))    self.pushButton_2.clicked.connect(self.close)</code></pre><p><strong>1.4将matplotlib绘制的图片（信号波形和实验波形）插入到GUI界面</strong></p><p>1.学习了用<strong>matplotlib</strong>绘图的基本方法，编写代码绘制实现了连续信号（阶跃、方波、正弦波、三角波、锯齿波），离散信号（单位序列、正弦序列、指数序列），信号和序列的相加相乘运算，卷积运算，方波合成与分解运算，不同间隔不同频率采样后的信号，不同滤波效果得到的信号等等。</p><p>2.实现信号后绘制得到了相应图片，通过使用<strong>label控件的setPixmap函数</strong>将matplotlib绘制的图片插入到Qt界面中。</p><p><strong>1.5实现多层界面转换（上一个界面仍然保留)，添加返回上一级按钮</strong></p><p>1.在每个界面的py文件中先导入需要跳转的界面模块，用<strong>QDialog</strong>函数来连接需要跳转到的下一个界面，用<strong>show</strong>函数和<strong>exec</strong>函数实现界面显示运行。</p><p>2.编写<strong>关闭函数</strong>，点击返回上一级按钮时将该界面关闭。</p><p><strong>1.6用PyInstaller将所有py文件打包成exe可执行文件</strong></p><p>1.在命令行中输入<strong>pyi-makespec 000_plot.py</strong>生成<strong>spec文件</strong>修改文本内容添加所有用到的py文件和图片数据并保存文件，在spec文件路径下打开命令行，输入<strong>pyinstaller -D 000_plot.spec</strong>生成exe程序。</p><p>2.生成的exe程序在dist文件夹中，dist文件夹里包含了整个项目所需的代码和环境，可在其他电脑中进行使用。（这里必须在<strong>Anaconda</strong>中打包而且打包后的文件非常大，用其它打包会出错）</p><p>3.最终打包成功了，文件夹比较大，点击exe文件每次都能成功打开系统。</p><h1 id="2-设计心得"><a href="#2-设计心得" class="headerlink" title="2 设计心得"></a>2 设计心得</h1><p>此次设计是在学习Python语言之后尝试完成的一项具体性设计任务，我也深刻体会到了Python在GUI设计方面功能的强大。完成任何一项设计都是不易的，从前期基础知识的学习，到自己动手后的不知所措，这个过程中我遇到了非常多的难题，针对难题也查阅了无数的经验帖和资料，功夫不负有心人，难题被一个接一个的解决了，不过因为我看到论文不够多经验不够目前还是有些难题存在困难或者解决的效果不够好。</p><p>此次任务，我发自内心地感受到了解决难题带给人的快乐，以后的学习中还是会遇到很多难题的，我会把这看成一件幸运的事情，<strong>遇到难题说明我正在提升的轨道上</strong>，只有攻克一道道难关才能看到最后的彩虹，加油向前冲！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020上半年我读的5本书</title>
      <link href="/2020/06/16/My-New-Post/"/>
      <url>/2020/06/16/My-New-Post/</url>
      
        <content type="html"><![CDATA[<h1 id="《当下的力量》"><a href="#《当下的力量》" class="headerlink" title="《当下的力量》"></a>《当下的力量》</h1><p><strong>1、如何处理生活中不管是身体上还是心理上会遇到的痛苦和情绪的不稳定。</strong> </p><ul><li>你可允许情绪的存在，但却不要受它控制。你不再是你的情绪，而是一个观察者。不是引用佛的话，而是变成佛，成为觉醒的人。</li><li>痛苦之身害怕被你发现。它的生存取决于你对它无意识的认同，以及你面对内在痛苦时，那种无意识的害怕。将注意力集中在你内心的感受上，了解到这就是痛苦之身并接受它的存在；别去想它，继续观察你的内在，不仅要觉知到你情绪上的痛苦，更要觉察那个沉默的观察者。</li></ul><p><strong>2、时刻保持“临在”，发觉吵闹背后的寂静和沉默，不仅会提高做事质量，也会让你内心更加坦然。</strong></p><ul><li>请不要将你所有的注意力集中在你的思维和外部世界上。尽量将注意力集中在你正在做的事情上，但是同时请尽可能地感受你的内在身体。在你的内在身体里扎根，然后观察这样做会如何改变你的意识状态和你的做事质量。</li><li>外界事物不会永远地满足你的需求，它们只会暂时地和表面上地满足你，但是你也许要多次体验这些失望后，才能认识到这些事实。事物和生活条件可以给你快乐，但它无法给你喜悦。喜悦是你内在宁静状态的关键部分。</li></ul><p><strong>3、无论发生什么，请选择宽恕和接纳，确保我们内心没有抗拒，没有仇恨，没有消极。</strong></p><ul><li>通过把你自己想象成是透明的，让引发反应的外部因素穿过你，进而使它消失。</li><li>不管当下时刻的情况怎样，心甘情愿地接受它，就像它是你选择的一样。总是与它共事，而不是抗拒它。</li><li>如果你发现你的“此时此地”变得无法忍受并且使你非常不开心，这时你有三种选择：从中离开，改变它，或者完全接受它。然后，你就应该接受你的选择所带来的后果。没有借口，没有消极的态度，没有精神上的污染，保持内在空间的清洁。</li></ul><h1 id="《原则》"><a href="#《原则》" class="headerlink" title="《原则》"></a>《原则》</h1><p><strong>1、人都会犯错，这并不可怕，我们需要做的是“正确的失败”，从失败的过程中总结教训和经验。</strong></p><ul><li>大多数人都有一定的情绪障碍，不愿坦率地面对自身的问题和弱点。他们不愿直面扑朔迷离的形势和艰难的挑战，在遇到这些情况时，人们通常会觉得不舒服。兼具常识，创造性和主动寻求改变等个性的人，简直凤毛麟角。</li><li>如果你没有经历过失败，就说明你没有努力突破极限，而如果你不努力突破极限，你就不能最大限度地挖掘自己的潜能。</li><li>展现真实的自我，而不是强行把弱点伪装成优势。把缺点摆上桌面将帮助你戒掉坏习惯，养成好习惯，获得真正的能力，拥有充足的理由保持乐观。</li></ul><p><strong>2、保持好奇心，时刻以谦逊的姿态对待别人，更注重答案本身，保持头脑开放。</strong></p><ul><li>你是在寻找最好的答案，而不是你自己能得出的最好答案。头脑封闭的人更关心是否被理解，而不是理解其他人。</li><li>找其他独立思考者，以一种经过深思熟虑的辩论方式与他们交流，从而理解他们的推理，并让他们对我的推理进行压力测试。我的目标只是让自己正确，我并不关心正确的答案是不是来源于我。</li><li>保持足够好奇心，始终愿意去理解那些看问题与你不一样的人是怎么形成他们看问题方式的。至少听一下某种相反的观点，永远都没有害处。</li></ul><p><strong>3、将复杂事情简单化，学会把握全局，只关注自己需要的和真正有价值的事情。</strong></p><ul><li>一些人毕生收集各种零零碎碎的看法和观点，他们有“细节焦虑症”，担忧不重要的事情。</li><li>正在发生的事情都似乎很大，回头来看则不然。所以我们应该跳出去看全局，过一段时间再做决定。</li><li>80/20法则：80%的价值只需要20%的努力或信息，而关键性的20%的价值需要花费80%的努力来获取。（如果你花大部分时间在不重要的80%价值上，剩下的20%关键的东西就无法获取。）</li></ul><h1 id="《非暴力沟通》"><a href="#《非暴力沟通》" class="headerlink" title="《非暴力沟通》"></a>《非暴力沟通》</h1><p><strong>1、非暴力沟通四要素：观察，感受，需求，请求。观察要不带评论，表达感受时不要陈述想法，表达自己的需求而不是指责对方，清楚告诉对方希望他们做什么而不是请求对方不做什么。</strong> </p><ul><li>暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方。</li><li>清楚地告诉对方，我们希望他们做什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底想要什么。而且，这样的请求还容易引起别人的反感。</li><li>区分请求和命令。一旦人们认为不答应我们就会受到责罚，他们就会把我们的请求看作是命令。如果我们清楚地表达我们无意强人所难，人们一般会相信，我们提出的是请求而非命令。</li></ul><p><strong>2、在集体讨论时，大家总是各自抒发自己的想法，进行着“无效沟通”。一场有价值的会议，应该从主题的出现开始，在贴合主题的反馈足够后停止。</strong></p><ul><li>如果不清楚发言者是否已经得到满意的答复，讨论就可能漫无目的地继续下去，而无法满足任何人的需要。</li><li>参加集体讨论时，说清楚我们希望得到怎样的反馈，是至关重要的。如果不清楚发言的目的，我们的讨论也许只是在浪费时间，而无法满足任何人的需要。</li></ul><p><strong>3、学会倾听，并乐于给别人反馈和感激别人。</strong></p><ul><li>如果一个人想要别人了解他的处境，听到的却是安慰和建议，那么，他就有可能觉得不太舒服。</li><li>我建议你说：“你不高兴，是因为你需要……”。这有助于你去了解他此刻的状态，而避免责备自己。如果一个人觉得别人已经完全明白他的意思，他就会变得轻松。这时，我们也会感到放松。</li><li>如果我们以苛刻的态度对人对己，我们的心情也好不到哪里去。通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心将逐渐变得平和。一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。</li></ul><h1 id="《最好的告别》"><a href="#《最好的告别》" class="headerlink" title="《最好的告别》"></a>《最好的告别》</h1><p><strong>1、接受变老，接受死亡。我们应该去了解临近死亡的人内心最大的恐惧和关心，以及他最重要的目标是什么，他愿意做哪些交换、不愿意做哪些交换。</strong></p><ul><li>生命接近终点时，人们希望分享记忆、传承智慧和纪念品、解决关系问题、确立遗产、与上帝讲和、确定留下的人能好好活着。他们希望按照自己的主张结束自己的故事。</li><li>我们最终的目的不是好死，而是好好地活到终了。</li><li>实际上，并不是某一种疾病导致了生命的消亡。我们时而降低血压，时而抗击骨质疏松，控制这种病，发现那种病，置换坏掉的关节、瓣膜，眼看着“中央处理器”渐渐衰竭。</li><li>我们的细胞有几个DNA修复系统。如果一个关键的基因永久性地损坏了，通常其附近就有额外的相同基因。而且，如果整个细胞都坏死了，那么，别的细胞就会填补进来。尽管如此，随着复杂系统的缺损增加，终有一天，某一个缺损就足以破坏整个系统，导致所谓的虚弱状态。</li><li>我们一直犹犹豫豫，不肯诚实地面对衰老和垂死的窘境。衰老是我们的宿命，死亡总有一天会降临。在人近黄昏之时，所需的不仅仅是医药，还有生活——有意义的生活，在当时情形下尽可能丰富和充足的生活。</li><li>我们终于迈进这样一个时代，在这个时代，越来越多的人认识到他们的工作不是以安全的名义限制人们的选择，而是以过有价值生活的名义扩大选择的范围。</li></ul><p><strong>2、面对癌症时更多人想的是再活十年二十年而不是一年两年，于是他们选择了化疗，这样往往得不到预期效果，而选择什么都不管的舒缓治疗反而可以提高癌症患者的生活质量。</strong></p><ul><li>我们面对的是无法解决的问题，但是我们固执地相信，我们面对的问题并非不可处理。</li><li>既然生命在逼近极限，那么，他希望他的故事的最后几行是安宁。</li><li>我父亲还是忍不住摆弄他的那些药，他开始记录自己的症状和服用的药品及服药的时间。来访的护士每天和他一起阅读他的记录，确定要做的调整。把今天过到最好、而不是为了未来牺牲现在。</li><li>在年老和患病的时候，人至少需要两种勇气。第一种勇气是面对人终有一死的事实的勇气——寻思真正应该害怕什么、可以希望什么的勇气。这种勇气已经够难了，但是更令人却步的是第二种勇气——依照我们发现的事实采取行动的勇气。</li></ul><p><strong>3、把我们还好好活着的时光过好，做对于自己更重要更有意义的事情。</strong></p><ul><li>表面看似幸福的生命可能是空虚的，而一个表面看似艰难的生活可能致力于一项伟大的事业。</li><li>随着年龄的增长，我们从在意实现、拥有和得到转而懂得欣赏日常生活的愉快和亲密关系，如果我们发现这更具满足感，那么，为什么我们要等这么久才去做？为什么我们要等到老了才去做？生活是一种技能。老年的平静和智慧是在时间历程中实现的。</li></ul><h1 id="《看不见的城市》"><a href="#《看不见的城市》" class="headerlink" title="《看不见的城市》"></a>《看不见的城市》</h1><h2 id="第一天读书总结"><a href="#第一天读书总结" class="headerlink" title="第一天读书总结"></a>第一天读书总结</h2><p>每座城市留给不同的人的记忆是不同的，我们有时会惊讶于别人描述的城市和我亲眼所见的简直大不相同，这是很正常的，这和每个人来这座城市之前的经历、来访者过去的记忆、来访者的年龄、来访的时长息息相关。当你在一座城市待久了，会有这座城市变小了的感觉。当你匆匆经过一座城市时，你在城市看到的某些手势某件物件更容易被你当做城市的符号。</p><p>就像人们都会说上海是繁荣大都市，各种风景照也展示了它的美丽，但其实你真正去到其中时会觉得这和我从小生长的小县城也没太大区别。城市不应该被它的符号限制，我们常常会过于追逐城市的符号而忘记自己为什么到访这座城市。</p><p>其实，每个城市的不同在于它的历史，在于它每一砖每一瓦的痕迹，而且城市会把它的过去藏起来，等你细细去发掘。</p><h2 id="第二天读书总结"><a href="#第二天读书总结" class="headerlink" title="第二天读书总结"></a>第二天读书总结</h2><p>作者把每座城市比作一位女子，到访城市像是在和她谈恋爱，每位女子的味道都不同，在她们身上你看到了自己不曾拥有的很多很多东西。当然，如果试图去改造她们则会适得其反，改造后的她们已经不是你当初喜欢的样子。</p><p>作者说其实你到访一座城市之前已经对她的基础框架有所了解，她们都不尽相同，但是填充的内容不同，这恰恰像不同性格的人。每个人都是一座城，不同的经历，价值观/目标各异，缤纷又繁杂。</p><p>作者把她分成两类：一类是经历岁月沧桑，而继续让欲望决定自己形态的人；另一类是要么被欲望抹杀掉，要么将欲望抹杀掉的人。</p><h2 id="第三天读书总结"><a href="#第三天读书总结" class="headerlink" title="第三天读书总结"></a>第三天读书总结</h2><p>表达是有限的，思想却是无限的。这里可能是个极度集权压迫的国家，都在压制着各自思想的表达。可不表达不意味着没有啊，不做不意味着不想啊，可能一星火苗，就点燃成熊熊大火，一瞬覆灭…</p><p>城市中的我们，内心渴望温存交流对酌倾诉，可又擦肩而过，心门紧闭，害怕受伤也害怕伤害别人。城市中的孤独者，有的人敏感而故作坚强，有的人麻木而昏昏欲睡，孤独的幽灵互撇一眼都害怕传染上对方的冷漠，殊不知自己的寒冷已冰冻千里。</p><h2 id="第四天读书总结"><a href="#第四天读书总结" class="headerlink" title="第四天读书总结"></a>第四天读书总结</h2><p>城市在她空着的棋盘上不断移动着，重复着她始终如一的生活。居民们反复演出同样的场景，只是更换了演员；他们重复着同样的台词，不过改变了口音而已；他们张开不同的嘴巴，打着同样的哈欠。在帝国的所有城市中，只有埃乌特洛比亚保持始终不变。</p><p>为什么埃乌特洛比亚始终不变？</p><p>因为城市从来没有更新、进步过。当居民不喜欢现状时，从不进行改变，而是逃避现状，不断开启新鲜，厌倦，换个地方新鲜，再厌倦的过程。城市无法经历迭代。</p><p>当我们时间长了厌倦一个地方或者厌烦一个人时，或者现状让自己很不舒服时，重要的不是想着逃避（换一个地方或者换一个人），而应该试着改变自己，可以到处走走或找人聊一聊，时刻记着让自己变化，不能一味寻找新鲜感。</p><h2 id="第五天读书总结"><a href="#第五天读书总结" class="headerlink" title="第五天读书总结"></a>第五天读书总结</h2><p>今日读到奥塔维亚城，虽然悬在深渊之上，奥塔维亚居民的生活并不比其他城市的更令人不安，他们知道自己的网只能支撑这么多。</p><p>今日还读到宝琪城，关于宝琪的居民，有三种假设：他们憎恨地球；他们敬畏地球，乃至尽量避免与地面的任何接触；他们喜欢自己出生之前的地球，以至利用各种望远镜不知疲倦地观察着每一片树叶，每一块石子，每一只蚂蚁，着迷地冥思自己杳然的存在。</p><p>像矛盾的现代人，羡慕自然，但也止于远观，绝不能离开自己身处的造物，城市就是一种造物。</p><h2 id="第六天读书总结"><a href="#第六天读书总结" class="headerlink" title="第六天读书总结"></a>第六天读书总结</h2><p>人到生命的某一时刻，他认识的人当中死去的会多过活着的。这时，你会拒绝接受其他面孔和其他表情：你遇见的每张新面孔都会印着旧模子的痕迹，是你为他们各自佩戴了相应的面具。</p><p>我也有过这个人真的好像好像我从前见过的某个人的感觉，一举一动一颦一笑简直一模一样，但是如果你定睛仔细看会发现他并不是之前那个人，只是一个全新的陌生人。</p><p>当你在一个城市待久了，你会慢慢看不到它的闪光点，对人也是，作者一直在谈论新鲜感的话题，现实也确实如此，时间会让我们失去新鲜感，我认为事物最重要的是要懂得变化，如果改变不了别人，时刻记得改变自己，会让生活更有趣。</p><h2 id="第七天读书总结"><a href="#第七天读书总结" class="headerlink" title="第七天读书总结"></a>第七天读书总结</h2><p>每个城市都有光鲜亮丽的场所，必然也有废旧腐烂的阴暗地 。“从这面到那面，城市的各种形象在不断翻番，但是却没有厚度，只有正反两面：就像一张两面都有画的纸，两幅画既不能分开，也不能对看。”</p><p>以为亡者在生者面前已无生机，生者即是现实，然而死去的城市死去的居民却活出了希望的自己。死者们甩掉了生前所有，甩掉了过去，过去的自己已经死去，如今是一种跨越的生。满是死亡气息的的埃乌萨皮娅成了向往，成了地上城市的遥不可及，死亡才是通行证。</p><p>地狱是大理石构筑的富丽宫殿，天堂不过是一间茅草屋，这是一个有关信仰的可笑荒谬的苦涩的寓言。</p><p>“新”是个非物质性的词。其实，我们的每一天都是新的，我们身处的环境每一天都是新的，包括我们自己。这个“新”，不在于是否“见”过。反而言之，很多初见的事物也是“旧”的，这个“旧”与“记忆”有关。也和“时空”有关。</p><h2 id="第八天读书总结"><a href="#第八天读书总结" class="headerlink" title="第八天读书总结"></a>第八天读书总结</h2><p>什么东西都不是独立的存在，背后总有他的生命周期，人们的一举一动，都有一定的心理学现象可以解释，侦探总是能优先破开迷局，也是通过细小的事物与事件本身的关联结合。培养自己的逻辑思维，学会去观察背后的秘密，那样你的话题，你的情感，你的思想不会枯竭。</p><p>掌握故事的是耳朵而不是声音。每个人听到的都只是自己想听到的，所以一个故事才有了无数个版本 </p><h2 id="第九天读书总结"><a href="#第九天读书总结" class="headerlink" title="第九天读书总结"></a>第九天读书总结</h2><p>《看不见的城市》最终以城市其实是人在破坏自然结局，以人类都会面临的死亡结局，这本书1972年出版，却能和现在发生的一切有所关联，颇感讽刺意味。</p><p>“城市，这座动物的大坟场，终于埋葬了最后一批带着跳蚤和细菌的老鼠腐尸。人类终于重新建立起被自己打乱的世界秩序：再也没有活着的物种能够对此提出疑问。”</p><p>科技在不断进步，人类在不断进化，可是他们恰恰没有想到大自然也不断进化－－以不变应万变。人类幻想建造理想的城市（征服大自然），而最后又出现新的麻烦。实际上这些新物种不是死去的动物，而是人类的异变。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
